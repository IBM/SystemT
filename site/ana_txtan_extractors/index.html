<!DOCTYPE html>
<html lang="en" data-bs-theme="light">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>AQL concepts - MkLorum</title>
        <link href="../css/bootstrap.min.css" rel="stylesheet">
        <link href="../css/fontawesome.min.css" rel="stylesheet">
        <link href="../css/brands.min.css" rel="stylesheet">
        <link href="../css/solid.min.css" rel="stylesheet">
        <link href="../css/v4-font-face.min.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link id="hljs-light" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" >
        <link id="hljs-dark" rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github-dark.min.css" disabled>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="..">MkLorum</a>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">

                    <ul class="nav navbar-nav ms-md-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-bs-toggle="modal" data-bs-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-bs-toggle="collapse" data-bs-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-body-tertiary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-bs-level="1"><a href="#aql-concepts" class="nav-link">AQL concepts</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-bs-level="2"><a href="#aql-extractors-overview" class="nav-link">AQL extractors overview</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#aql-modules" class="nav-link">AQL modules</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-bs-level="2"><a href="#aql-files" class="nav-link">AQL files</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="aql-concepts">AQL concepts</h1>
<p>{:.no_toc}</p>
<ul>
<li>Table of Contents
{:toc}</li>
</ul>
<h2 id="aql-extractors-overview">AQL extractors overview</h2>
<p>Extractors are programs that extract structured information from unstructured or semistructured text by using AQL constructs. </p>
<p>An extractor consists of compiled modules, or Text Analytics module (TAM) files, and content for external dictionary and table artifacts. 
At a high level, the extractor can be regarded as a collection of views, each of which defines a relationship. 
Some of these views are designated as output views, while others are non-output views. 
In addition, there is a special view called <code>Document</code>. 
This view represents the document that is being annotated. 
Furthermore, the extractor might also have <code>external views</code> whose content can be customized at run time with extra metadata about the document that is being annotated.</p>
<p>The following figure illustrates how SystemT compiles and runs extractors.</p>
<p><img alt="Compiling and executing Text Analytics projects: an AQL file is compiled, an efficient execution plan is produced, and the plan is fed into the runtime component." src="images/AQL_runtime_v2.gif" title="Compiling and executing Text Analytics projects" /></p>
<ol>
<li>The SystemT Optimizer compiles the source modules into compiled TAM files.</li>
<li>An extractor is instantiated based on a set of one or more compiled modules, with the content for external dictionaries and tables that are required by these modules. You can reuse and combine modules to create more complex extractors. This process results in a complete executable plan for the extractor.</li>
<li>This executable plan is passed as input to the SystemT runtime component.</li>
<li>External views can be included as input to customize the extractor by your data needs.</li>
<li>SystemT has a document-at-a-time runtime model, which means that at run time, the view <code>Document</code> is populated with a single tuple that represents the content of the document to process.</li>
<li>The runtime component then runs the execution plan and populates the output views of the extractor with the extracted results.</li>
</ol>
<h2 id="aql-modules">AQL modules</h2>
<p>Text Analytics modules are self-contained packages. 
They contain a set of text extraction rules that are created by using AQL, 
and other resources that are required for text extraction.</p>
<ul>
<li><a href="#structure-of-a-module">Structure of a module</a></li>
<li><a href="#documenting-a-module-with-aql-doc-comments">Documenting a module with AQL Doc comments</a></li>
<li><a href="#example">Example</a></li>
<li><a href="#scenarios-that-illustrate-modules">Scenarios that illustrate modules</a></li>
<li><a href="#best-practices-for-developing-modules">Best practices for developing modules</a></li>
</ul>
<h3 id="structure-of-a-module">Structure of a module</h3>
<p><img alt="Source modules are composed of AQL files, dictionary files, user-defined function (UDF) JAR files, and module information. The Optimizer creates a Text Analytics module (TAM) file from the module." src="images/AQL_module.gif" title="The structure of a module" /></p>
<p>Resources that are included in a source module can include AQL files, dictionary files, UDF JAR files, and a special file named <code>module.info</code> that contains the AQL Doc comment that details the specifics of the module. 
When you import a module, these resources in the form of AQL objects (such as a <code>view</code>, <code>table</code>, <code>dictionary</code>, or <code>function</code>) are available for reuse. 
This increases the efficiency of development.</p>
<p>The structure of a module consists of, and is defined by, a top-level folder. The name of the folder is also the name of the module. One or more AQL files are located directly in the top-level module folder. AQL files that are located within subdirectories of the top-level folder are ignored by the compiler. Dictionary files and UDF JAR files can be located in the top-level module folder, or within subdirectories of the module folder. References to these files inside a module must be done by using a path relative to the top-level module folder.</p>
<p>Compiling your source module results in a TAM file that includes:</p>
<ul>
<li>The compiled form of the AQL files, which is known as the execution plan</li>
<li>Metadata of the elements that are defined in the module</li>
</ul>
<p>Module metadata includes all of the details that are necessary to consume the module without instantiating the module. These details include the following information:</p>
<ul>
<li>The schema of the special view <code>Document</code></li>
<li>The views (output, external, and exported) with the schema and AQL Doc comments, and cost information that is associated with the view that is used to optimize modules that depend on this view</li>
<li>The tables (external and exported) with the schema and AQL Doc comments</li>
<li>The dictionaries (external and exported) with AQL Doc comments</li>
<li>The exported functions with AQL Doc comments</li>
<li>The type of tokenizer used to compile the dictionaries of the module (This tokenizer must coincide with the tokenizer used at execution time)</li>
<li>Any other modules that this module depends on, such as modules needed at compile time or at initialization time, to ensure that all components of the extractor are completely loaded</li>
</ul>
<p>After you have a compiled module, you can combine the modules or reuse modules that contain established AQL elements, such as tables and artifacts, to build new extractors. 
Your AQL project can be modified easily with modular AQL, and you can reuse your data and share your projects with others.</p>
<h3 id="documenting-a-module-with-aql-doc-comments">Documenting a module with AQL Doc comments</h3>
<p>Each module should have a comment that describes its high-level semantics. The comment for a module is placed in a file named module.info in the module folder. This file contains only the comment for the current module.</p>
<p>Capture the following information in a module-level comment:</p>
<ul>
<li>A high-level description that contains the application areas, types of data sources, and languages used</li>
<li>The schema of the <code>Document</code> view</li>
<li>Author information</li>
<li>The customization points of the module, and what must be modified to customize the module for a different domain or language</li>
<li>Any other assumptions necessary to effectively use the module.</li>
<li>Input format expectations</li>
<li>Expectations about the data source, for example, the domain and average size of the documents on which the module is expected to perform</li>
<li>Higher level types of analysis that the module completes</li>
<li>Patterns that are captured or not captured by the module</li>
<li>Specific tags to represent the information</li>
</ul>
<p>The module comment format consists of a top-level comment followed by a tag. The following pre-defined special AQL Doc comment tags can be used to convey specific portions of the module information. Any other necessary information that does not fall into any of the specific tags should be included in the top-level comment.</p>
<ul>
<li>
<p><strong>@appType</strong></p>
<p>Specifies application type and areas that are covered by the module. For example, one can specify whether the extractor works for a specific vertical, such as financial, or healthcare, or a cross vertical, such as Social Media Analytics.</p>
</li>
<li>
<p><strong>@dataSource</strong></p>
<p>Specifies data sources that the module expects to work with or was tested with. For example, you can indicate the type of input documents that the extractor works with, such as email, social media data, news reports. You can also indicate other characteristics of the data, such as:</p>
</li>
<li>
<p>The average document size</p>
</li>
<li>The type of content (formal or informal/noisy)</li>
<li>
<p>The structure (completely unstructured, semi-structured such as HTML or XML, or intrinsic structured such as log records)</p>
</li>
<li>
<p><strong>@languages</strong></p>
<p>A comma-separated list of language codes that are supported by the module.</p>
</li>
<li>
<p><strong>@author</strong></p>
<p>The name of the author of this module – one each for every author.</p>
</li>
<li>
<p><strong>@docField</strong></p>
<p>A tag each for every field in the required input document schema of the module.</p>
</li>
</ul>
<h3 id="example">Example</h3>
<p>Consider this common AQL module comment format:</p>
<pre><code class="language-bash">/**
* This module contains extractors for social data analytics. Extractors include Buzz, Intent, Sentiment, and Person microsegmentation.
*
* @appType  Social Data Analytics
* @dataSource   Supports social media data
* @languages    en,fr,de
* @docField     text the content of the social media message
* @docField     location the “location” field of a social media data record. Used for extracting attributes such as city and state.
* 
*/
</code></pre>
<h3 id="scenarios-that-illustrate-modules">Scenarios that illustrate modules</h3>
<p>You can use common design patterns to create Text Analytics modules. 
These examples encompass various AQL statements, and each example uses the AQL Doc comments to explain the code.</p>
<h4 id="importing-and-exporting-modules">Importing and exporting modules</h4>
<p>In the following example, the module <code>personEn</code> creates and makes a view available called <code>Person</code>. The module <code>signature</code> reuses the views from the <code>personEn</code> and <code>email</code> modules.</p>
<pre><code class="language-bash">module personEn; 

/**
 * Extract mentions of person names, primarily from English text. 
 * Limited support for Italian and French.
 *
 * @field fullName person's complete name
 * @field firstName person's given name (optionally populated, when possible)
 * @field lastName person's surname (optionally populated, when possible)
 */
create view Person as
select P.name as fullName, P.first as firstName, P.last as lastName
from PersonFinal P;

export view Person;
</code></pre>
<pre><code class="language-bash">module signature; 

import view Person from module personEn;
import view EmailAddress from module email as Email;  
/**
 * Find mentions of person full names followed 
 * within 0 to 5 tokens by an email address.
 *
 * @field match the span covering the full name and email address
 */
create view PersonWithEmail as
extract pattern &lt;P.fullName&gt; &lt;Token&gt;{0,5} &lt;E.address&gt; as  match 
  from personEn.Person P, Email E;

output view PersonWithEmail;
</code></pre>
<p>This example illustrates the two forms of the <code>import view</code> statement:</p>
<ul>
<li>
<p>Without a local name.</p>
<p>The name, fully qualified by module name (<code>personEn.Person</code>), is placed in the namespace of the current module.</p>
</li>
<li>
<p>With a local name.</p>
<p>The local name <code>Email</code> is placed within the namespace of the current module <code>signature</code>, instead of the fully qualified name <code>email.EmailAddress</code>.</p>
</li>
</ul>
<p>The name that is imported from the first module is used throughout the second module in the <code>from</code> clause of that statement, which uses the fully qualified name, or the local name for the two views.</p>
<h4 id="domain-customization-of-an-extractor">Domain-customization of an extractor</h4>
<p>In the following example, <code>common</code> is a library of basic extractors that are useful for Machine Data Analysis. The <code>datapower</code> and <code>syslog</code> modules are implementations of Machine Data Analysis extractors for two different types of logs. The <code>extractor_datapower</code> and <code>extractor_syslog</code> modules import relevant libraries and output the views.</p>
<pre><code class="language-bash">module common; 
/**
 * Extract mentions of IP addresses of 
 * the form xxx.xxx.xxx.xxx
 * from the text field of view Document.
 *
 * @field address the IP address
 */
create view IP as … ;
export view IP;
</code></pre>
<pre><code class="language-bash">module datapower; 
import module common;
/**
 * Extract mentions of DeviceIP addresses. In DataPower logs,
 * let’s imagine that the DeviceIP is the first IP mention 
 * after the timestamp.
 * @field address the IP address
 */
create view DeviceIP as … ;
export view DeviceIP;
</code></pre>
<pre><code class="language-bash">module syslog; 
import module common;
/**
 * Extract mentions of DeviceIP addresses. In system logs,
 * let’s imagine the DeviceIP is at the end of the log record,
 * so we must provide an implementation different than for DataPower.
 * @field address the IP address
 */
create view DeviceIP as … ;
export view DeviceIP;
</code></pre>
<pre><code class="language-bash">module extractor_datapower; 
import module datapower;

output view datapower.DeviceIP as 'DeviceIP';
</code></pre>
<pre><code class="language-bash">module extractor_syslog; 
import module syslog;

output view syslog.DeviceIP as 'DeviceIP';
</code></pre>
<p>The <code>import module</code> statement makes names available that are fully qualified by the module name. The view names (and dictionary, table, and function names) are always fully qualified by the module name. The <code>output view DeviceIP</code> results in different output names (such as <code>datapower.DeviceIP</code> and <code>syslog.DeviceIP</code>). The application code must change depending on which modules you use for extraction. For example, Extractor1 (which uses common, datapower, and extractor_datapower) and Extractor2 (which uses common, syslog, and extractor_syslog) generate different output names for the DeviceIP type. The best practice is to use the <code>output view &lt;view-name&gt; as '&lt;alias&gt;'</code> statement. The <code>output view &lt;moduleName&gt;.DeviceIP as 'DeviceIP'</code> results in both Extractor1 and Extractor2 exporting identical names, DeviceIP.</p>
<h4 id="combining-modules-to-create-an-extractor">Combining modules to create an extractor</h4>
<p>You can combine modules to create an extractor. This example uses two modules, <code>phone</code> and <code>person</code>, to create an extractor that identifies all of the occurrences of a person with a phone number that immediately follows it (for example, the view <code>PersonPhone</code>). The <code>Person</code> and <code>PhoneNumber</code> views might be used in other extractors, so they are placed in separate modules for easy reuse.</p>
<pre><code class="language-bash">module phone;

create view PhoneNumber as
select P.num as number
from
{
extract
   regexes /\+?\[1-9]\d{2}\)\d{3}-\d{4}/ and /\+?[Xx]\.?\d{4,5}/
   on D.text as num
from Document D
} P;

export view PhoneNumber;

</code></pre>
<pre><code class="language-bash">module person;

-- first names, derived from a dictionary of common first names
create dictionary FirstNameDict from file ‘dictionaries/first.dict’;

create view FirstName as
extract dictionary FirstNameDict on D.text as name
from Document D;


-- last names, derived from a dictionary of common last names
create dictionary LastNameDict from file ‘dictionaries/last.dict’;

create view LastName as 
extract dictionary LastNameDict on D.text as name
from Document D;


-- a person is a first name followed immediately by a last name
create view Person as 
select F.name as firstName, L.name as lastName, CombineSpans(F.name, L.name) as person
from FirstName F, LastName L
where FollowsTok(F.name, L.name, 0, 0);

export view Person;

</code></pre>
<pre><code class="language-bash">module personPhone;

import module person;
import module phone;

-- generate people followed immediately by a phone number
create view PersonPhone as 
select PE.person as name, PH.number as number 
from person.Person PE, phone.PhoneNumber as PH
where FollowsTok(PE.person, PH.number, 0, 0);

output view PersonPhone;

</code></pre>
<h4 id="building-a-library-of-udfs">Building a library of UDFs</h4>
<p>This example illustrates a common design pattern on how to build a module of user-defined functions (UDFs) that you can reuse in other modules.</p>
<p>The module <code>normalizationLib</code> defines and exports one UDF function. The module <code>signature</code> reuses all of the views, tables, dictionaries, and functions that are made available by the <code>personEn</code> module, and one function from the <code>normalizationLib</code> module. Although the <code>import function</code> statement is not illustrated in this example, it is similar to other <code>import</code> statements in that it has two forms; with or without local name. Notice in the example, the use of the local name of the function, <code>normalize</code>, in the <code>select</code> clause of the view <code>PersonNormalized</code>:</p>
<pre><code class="language-bash">module normalizationLib; 

/**
 * UDF function for normalizing a span value.
 *
 * @param val the input span value
 * @return string content of the span, normalized as follows:
 *         all characters converted to lower case;
 *         multiple consecutive white spaces replaced by a single space
 */
create function normalizeSpan(val Span)
return String
external_name 'udfjars/exampleUDFs.jar:textanalytics.udf.ExampleUDFs!norm'
language java 
deterministic
return null on null input;

export function normalizeSpan;
</code></pre>
<pre><code class="language-bash">module signature; 

import module personEn;
import function normalizeSpan from module normalizationLib as normalize;

/**
 * Generate a normalized version of a Person mention 
 * by replacing consecutive white spaces with a single space
 * and converting the result to lower case.
 *
 * @field normFullName normalized string representation of the full name
 */
create view PersonNormalized as
select normalize(P.fullName) as normFullName
from personEn.Person P;
</code></pre>
<h4 id="customizing-dictionaries">Customizing dictionaries</h4>
<p>In this example, the <code>commonPersonNames</code> module makes two dictionaries available, an internal dictionary and an external dictionary. The external dictionary is initially empty (at compile time). It is populated at initialization time. The format for the external dictionary file is .dict. There is one dictionary entry per line.</p>
<p>The scope of <code>set default dictionary language</code> is all external or internal dictionaries inside the entire module (not just the current AQL file) because the statement does not use the <code>with language as</code> clause. The <code>set default dictionary language</code> statement affects only the dictionary CustomFirstNames_WesternEurope because this dictionary is declared without an explicit <code>with language as</code> clause. In contrast, the statement does not affect the dictionary FirstNames_en_fr because that dictionary is declared with an explicit <code>with language as</code> clause.</p>
<pre><code class="language-bash">module commonPersonNames; 
set default dictionary language as 'en,fr,it,de,pt,es';
/**
 * Dictionary of top 1000 baby names in the U.S. and France. 
 * Evaluated on English and French text only.
 */
create dictionary FirstNames_en_fr 
from file 'dicts/firstNames.dict'
with language as 'en,fr';

/**
 * Customizable dictionary of first names.
 * Evaluated on English, French, Italian, German, Portuguese, Spanish text.  
 */
create external dictionary CustomFirstNames_WesternEurope
allow_empty true;

export dictionary FirstNames_en_fr;
export dictionary CustomFirstNames_WesternEurope;
</code></pre>
<pre><code class="language-bash">module personWesternEurope;

import dictionary FirstNames_en_fr from module commonPersonNames;
import dictionary CustomFirstNames_WesternEurope from module commonPersonNames
               as CustomFirstNames ;


/**
 * Find mentions of common first names. Use a variety of 
 * person first names in various languages, 
 * as well as a customizable external dictionary 
 */
create view FirstName as
extract dictionaries commonPersonNames.FirstNames_en_fr 
                 and CustomFirstNames
                 -- and &lt;... other dictionaries here ...&gt;
        on D.text
        as name
from Document D; 
</code></pre>
<h4 id="customizing-tables">Customizing tables</h4>
<p>In this example, the <code>sentiment</code> module makes available an external table of product names. As with external dictionaries, external tables are initially empty at compile time. They are populated at initialization time. The format of the external table is a .CSV file with a header. The first row is the header and the other rows are the table rows.</p>
<p>Internal tables and external tables can be imported in two ways, with or without local name. As with an internal table, you can create a dictionary from a column of an external table. However, you cannot create a dictionary from an external table that is imported. The work-around for this issue is to create the dictionary in the same module where the external table is defined.</p>
<pre><code class="language-bash">nickName,formalName
“Canon 1D”,”Cannon EOS 1D”
“Canon 1”,”Cannon EOS 1D”
“Canon 7”,”Canon EOS 7”
</code></pre>
<pre><code class="language-bash">module sentiment;
/**
 * A table of products around which we extract sentiment. 
 * 
 * @field nickName common name for the product as it may appear in text
 * @field formalName formal name of the product, used for normalization
 */
create external table Product (nickName Text, formalName Text)
allow_empty false;

/**
 * Dictionary of product nicknames, from the nickName field 
 * of the customizable external table Product.
 */
create dictionary ProductDict 
from table Product 
with entries from nickName;

create view ProductSentiment as 
extract pattern 'I like' (&lt;P.match&gt;)return group 1 as product
from (
extract dictionary 'ProductDict' on D.text as match
from Document D
) P;

/**
 * Products with positive sentiment.
 * @field nickName product mention extracted from the text
 * @field formalName normalized name of the product
 */
create view ProductLikeNormalized as
select S.product as nickName, P.formalName
from ProductSentiment S, Product P
where Equals(GetText(S.product), P.nickName);

export view ProductLikeNormalized;
</code></pre>
<h4 id="using-custom-documents-and-external-views">Using custom documents and external views</h4>
<p>In this example, the module <code>common</code> defines the schema of the special view Document, which contains two attributes: <code>twitterID</code> of type Integer and <code>twitterText</code> of type Text. The module also uses additional metadata about the document, in the form of a set of hash tags that are defined by using the <code>HashTags</code> external view.</p>
<p>You can write extractors that operate on documents with additional metadata. There are two types of metadata:</p>
<ul>
<li>
<p>Scalar-value metadata.</p>
<p>Use fields in the view Document (the <code>require document with columns</code> statement). The scope of the statement is the entire module, not just the current AQL file.</p>
</li>
<li>
<p>Set-value metadata</p>
<p>Use external views.</p>
</li>
</ul>
<p>The JSON data collection format (Hadoop) is used to represent custom documents and external view content. The existing data collection formats work only with the default Document schema (text Text, label Text). The JSON text format is defined by one record per line. Each record contains content for the Document and external views.</p>
<p>The AQL Doc is in the module.info file that documents the entire module.</p>
<pre><code class="language-bash">module common;

require document with columns 
twitterId Integer and twitterText Text;

/**
 * Hash tags associated with a Twitter message.
 * @field tag string content of the hash tag, without #
 */
create external view HashTags (tag Text)
external_name 'Hashes';

/**
 * Input documents that contain at least one hashtag
 * are treated in a special way during extraction.
 * @field twitterText the Twitter message text
 * @field twitterId the Twitter ID, as integer
 * @field tag tags associated with the twitter message 
 */
create view DocumentWithHashTag as
select D.twitterId, D.twitterText, H.tag  
from Document D, HashTags H;

output view DocumentWithHashTag;
</code></pre>
<pre><code class="language-bash">{“twitterId”:12345678, “twitterText”:”Gone fishing”, “ExternalViews”:{“Hashes”:[{“tag”:”halfmoonbay”}]}}
{“twitterId”:23456789, “twitterText”:”Gone surfing”, “ExternalViews”:{“Hashes”:[{“tag”:”usa”}, {“tag”:”santacruz”}]}}
</code></pre>
<h3 id="best-practices-for-developing-modules">Best practices for developing modules</h3>
<p>These best practices present practical advice to improve your modules.</p>
<ul>
<li>
<p>Document the source code by using AQL Doc comments.</p>
<p>Document your exported artifacts, the output views, the <code>Document</code> view, and the module itself. By using informative AQL Doc comments, you can make sure that your module is consumable by others in the expected fashion.</p>
</li>
<li>
<p>Place large dictionaries and tables in separate modules.</p>
<p>When you place large dictionaries and tables that do not frequently change in separate modules, it results in a decrease in compilation time for the entire extractor.</p>
</li>
<li>
<p>Place UDF JAR files in their own separate module and export the functions.</p>
</li>
<li>
<p>Build a library of UDFs that you can reuse in other modules to decrease unnecessary redundancy of the files.</p>
</li>
<li>
<p>Do not use the <code>output view</code> statement when you develop extractor libraries.</p>
<p>The <code>output</code> directive in one module cannot be overridden in another module. If you do not use the output statement in your extractor library, the consumer of the library can choose what types to output.</p>
</li>
<li>
<p>Use the <code>output view … as …</code> statement when you customize an extractor for different domains.</p>
<p>The use of this statement ensures that output names are identical across different implementations of the customization.</p>
</li>
</ul>
<h2 id="aql-files">AQL files</h2>
<p>AQL files are text files that contain text extraction rules that are written in the AQL programming language. A module contains one or more AQL files.</p>
<p>AQL files are a way of managing your AQL artifacts separately from larger dictionary files and reusable UDF files to increase performance and opportunities for modularization. AQL files include:</p>
<ul>
<li>
<p><strong>A module statement</strong></p>
<p>A module statement indicates the name of the containing module. AQL files must be placed directly under the top-level module directory. The first statement in an AQL file must be <code>module &lt;module name&gt;</code> to indicate the name of the containing module. These files are not allowed to be in subdirectories, therefore there can be no submodules.</p>
</li>
<li>
<p><strong>The AQL statements for defining artifacts (view, dictionary, table, function)</strong></p>
<p>AQL files provide the definition of AQL artifacts by using views, dictionaries, tables, and user-defined functions. The scope of the statement is the entire module, not just the current AQL file.</p>
</li>
<li>
<p><strong>The export statements</strong></p>
<p>Export statements expose the artifacts created in the module to other modules. Unless exported, an artifact is private to that specific module. You can use the <code>import</code> statement to reuse artifacts from another module.</p>
</li>
<li>
<p><strong>The create external dictionary statements</strong></p>
<p>These statements allow you to customize dictionaries without recompiling AQL. The content is generated when the extractor is initialized, and the dictionary remains constant for each document that is annotated.</p>
</li>
<li>
<p><strong>The create external table statements</strong></p>
<p>These statements allow you to customize tables without recompiling AQL. The content is generated when the extractor is initialized, and the dictionary remains constant for each document that is annotated.</p>
</li>
<li>
<p><strong>The require document with columns statement</strong></p>
<p>This statement defines the necessary columns in the view <code>Document</code>.</p>
</li>
<li>
<p><strong>The set default dictionary language statement</strong></p>
<p>Defines the default set of languages to use when you compile a dictionary that is defined without the with language clause. When you compile a dictionary, you must tokenize each dictionary in each language.</p>
</li>
</ul>
<h3 id="views">Views</h3>
<p>A view is a logical statement that defines what to match in your document or how to refine your extraction. Views are the top-level components of an extractor.</p>
<p>A common way that views are used is to define what to match in a document. Views can also be used to select information from previously created views to refine or combine constraints, and to define what to return (as tuples) when the AQL script is run. Views define the tuples, but do not compute them. All of the tuples in a view have the same schema</p>
<p>There are three types of views in AQL:</p>
<ul>
<li>Internal views describe content that is computed, if necessary, by the extractor, which is based on the input that is supplied at run time in the special view <code>Document</code>, and the external views. To define an internal view, use one of the statements:</li>
<li>The <code>create view</code> statement</li>
<li>The <code>detag</code> statement</li>
<li>The <code>select into</code> statement</li>
<li>The special view <code>Document</code> is the most basic view that captures the input document. The view <code>Document</code> is populated at run time with the necessary values for each of the attributes of its schema. By default, the schema of this view is <code>text: Text, label: Text</code>, but you can specify a custom schema by using the <code>require document with columns</code> statement.</li>
<li>External views define content that is not explicitly specified at compile time. External views are useful if you want to inject metadata about the input document that cannot be captured by using the <code>Document</code> view. For example, if you want to use metadata that cannot be represented as scalar values. To define an external view, use the <code>create external view</code> statement.</li>
</ul>
<p>The SystemT engine does not compute the content of a view unless you explicitly request it by using the <code>output view</code> or <code>select into</code> statements. For more information about the <code>Document</code> view and external views, see the AQL execution model.</p>
<p>Views can be used in the following AQL constructs:</p>
<ul>
<li>The <code>from</code> clause of a <code>select</code> or <code>extract</code> statement</li>
<li>The target of an <code>extract</code> statement or <code>detag</code> statement</li>
<li>The <code>export</code> or <code>import</code> statements to expose the view, and then use the view in another module</li>
</ul>
<p>The following is a simple example that illustrates how you can define an internal view and specify that it should be computed:</p>
<pre><code class="language-bash">require document with columns text Text;

create view Phone as
  extract regex /(\d{3})-\d{4}/ 
   on 3 tokens in D.text 
   return 
    group 0 as fullNumber
    and group 1 as areaCode
from Document D;

output view Phone;
</code></pre>
<p>The first statement specifies that the view <code>Document</code> has an attribute that is called <code>text</code> of type Text. Consider that the value of the <code>text</code> field in the input document is <code>My number is 555-1234, yours is 500-5678</code>. The extractor that is specified by this AQL code computes a view <code>Phone</code> with the schema <code>fullNumber: Span, areaCode: Span</code>. The content consists of the tuples <code>[beginOffset, endOffset]</code>. Notice that the span values are shown for clarity in the format <code>'matched text'</code>.</p>
<table>
<thead>
<tr>
<th>fullNumber</th>
<th>areaCode</th>
</tr>
</thead>
<tbody>
<tr>
<td>'320-555-1234' [13-24]</td>
<td>'320' [13-16]</td>
</tr>
<tr>
<td>'480-500-5678' [32-43]</td>
<td>'480' [32-35]</td>
</tr>
</tbody>
</table>
<h3 id="dictionaries">Dictionaries</h3>
<p>A dictionary is a set of terms that is used to identify matching words or phrases in the input text.</p>
<p>There are two types of dictionaries in AQL:</p>
<ul>
<li>Internal dictionaries contain content that is fully specified in AQL. Internal dictionaries are compiled and serialized in the compiled representation of AQL code (TAM files). To define an internal dictionary, use the <code>create dictionary</code> statement.</li>
<li>External dictionaries contain content that is not specified in AQL. Instead, the content is supplied when the compiled extractor is run. You can customize extractors for different scenarios with external dictionaries. You can supply different content for the external dictionary for each scenario without needing to recompile the source AQL of your extractor. The content of external views might change for each input document. However, the content of external dictionaries remains the same throughout a particular instantiation of the extractor. External dictionaries can be defined directly by using the <code>create external dictionary</code> statement, or indirectly by using the <code>create dictionary from table</code> statement if the table is an external table.</li>
</ul>
<p>Dictionaries can be used in the following AQL constructs:</p>
<ul>
<li>The <code>extract dictionary</code> statement to identify all matches of dictionary entries in the input</li>
<li>The MatchesDict() and ContainsDict() predicates to test if the input precisely matches or contains a match for one of the dictionary terms</li>
<li>The <code>export</code> and <code>import</code> statements to expose the dictionary and then use the dictionary in another module</li>
</ul>
<h3 id="tables">Tables</h3>
<p>A table is a static set of tuples in a file that contains the terms that you want to use in your extractor.</p>
<p>The content of views can differ for every input document that is processed by the extractor, but the content of a table is static and remains unchanged for the lifetime of an extractor. You can use internal and external tables when you develop your module. There are two types of tables in AQL:</p>
<ul>
<li>Internal tables have content that is fully specified in AQL, and the content is compiled and serialized in the compiled representation of AQL code (TAM files). To define an internal table, use the <code>create table</code> statement</li>
<li>External tables have content that is not specified in AQL. Instead, the content is supplied when the compiled extractor is run. Extractors can be customized for different scenarios with external tables. You can supply different content for the external table for each scenario without recompiling the source AQL of your extractor. Unlike external views, whose content can change for each input document, the content of external tables remains the same throughout an instantiation of the extractor. External tables can be defined by using the <code>create external table</code> statement.</li>
</ul>
<p>Tables can be used in the following AQL constructs:</p>
<ul>
<li>The <code>from</code> clause of a <code>select</code> or <code>extract</code> statement.</li>
<li>The <code>create dictionary from table</code> statement.</li>
<li>The <code>export</code> and <code>import</code> statements to expose the table and then run the table in another module.</li>
</ul>
<h3 id="functions">Functions</h3>
<p>A user-defined function (UDF) specifies custom functions that you can use in your extraction rules.</p>
<p>AQL has a collection of built-in functions and predicates that you can use in extraction rules. If the built-in functions and predicates are not sufficient for your extraction task, you can define your own user-defined function (UDF) in AQL by using the <code>create function</code> statement. AQL supports scalar UDFs and table UDFs that are implemented in Java. A scalar UDF outputs a single scalar value, whereas a table UDF outputs a multiset of tuples.</p>
<p>UDFs can be used in the following AQL constructs:</p>
<ul>
<li>Scalar UDFs can be used in all constructs where built-in functions can be used, such as the <code>where</code> clause of a <code>select</code> statement and the <code>having</code> clause of the <code>extract</code> statement.</li>
<li>Table UDFs can be used in the <code>from</code> clause of a <code>select</code> or <code>extract</code> statement.</li>
<li>The <code>export</code> and <code>import</code> statements to expose the function, and then use the function in another module. For more information about how to build libraries of user-defined functions, see Scenarios that illustrate modules.</li>
</ul>
<p>For more information about how to define, implement, and use UDFs, see the user-defined functions topics in the AQL reference.</p></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../js/bootstrap.bundle.min.js"></script>
        <script>
            var base_url = "..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../js/base.js"></script>
        <script src="../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>

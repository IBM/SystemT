/*******************************************************************************
* Copyright IBM
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*******************************************************************************/

module PersonCandidates;

-- Used for filtering Person names containing a single new line

create view PersonStrong as
select P.person as person
from PersonStrongWithNewLine P
where Not(ContainsRegex(/((\r\n|\t){2,}|(\r|\t){2,}|(\n|\t){2,})/, P.person));

create view PersonWeak1 as
select P.person as person
from PersonWeak1WithNewLine P
where Not(ContainsRegex(/((\r\n|\t){2,}|(\r|\t){2,}|(\n|\t){2,})/, P.person));

create view PersonWeak2NoNewLine as
select P.person as person
from PersonWeak2WithNewLine P
where Not(ContainsRegex(/[\n\r\t]/, P.person));

create view PersonWeak2 as
select P.person as person
from PersonWeak2NoNewLine P
where 
-- do not allow to be part of a list
      Not(MatchesRegex(/(.|\n|\r)*,[ \t]*(\p{Lu}\p{M}*(\p{L}\p{M}*|[-'.])*[ \t]*){0,2}/, LeftContext(P.person, 50)))
  and Not(MatchesRegex(/[ \t]*(\p{Lu}\p{M}*(\p{L}\p{M}*|[-'.])*[ \t]*){0,2}([,&]|(\b(and)[ \t]+))(.|\s)*/, RightContext(P.person, 50)))
-- do not allow to be preceded by greetings
  and Not(ContainsDict('Greetings', LeftContext(P.person, 15)));

-- union all names with pattern (FirstName LastName)
create view PersonFirstNameLastName as
	(select P.person as person from PersonStrong P)
	union all
	(select P.person as person from PersonWeak1 P);

-- remove matches in patterns (LastName, FirstName) that overlaps with patterns in (FirstName LastName)
create view InvalidPersonWeak2 as
select P2.person as person 
from PersonWeak2 P2,
	 PersonFirstNameLastName P1
where Overlaps(P1.person, P2.person)
 and Not(ContainsRegex(/[\n\r\t]/, P1.person));

create view ValidPersonWeak2 as
	(select P.person as person from PersonWeak2 P)
	minus
	(select P.person as person from InvalidPersonWeak2 P);


-- union all valid weak person candidates
create view PersonWeakWithoutNewLine as
	(select P.person as person from PersonWeak1 P)
	union all
	(select P.person as person from ValidPersonWeak2 P);
	

/**
 * Remove annotations created by relaxed rules overlapping with those
 * generated by stronger rules (e.g., rule 4r1 vs. rule 4) 
 */
create view PersonWeakOverlap as
select P1.person as person
from   PersonWeakWithoutNewLine P1,
       PersonStrong P2
where  Overlaps(P1.person, P2.person)
  and  Not(Contains(P1.person, P2.person));

create view PersonWeakOnly as
	(select P.person as person from PersonWeakWithoutNewLine P)
	minus
	(select P.person as person from PersonWeakOverlap P);
  
/**
 * Union all the person names identified by the above rules
 */

create view PersonAll as
	(select P.person as person from PersonWeakOnly P)
union all
	(select P.person as person from PersonStrong P);
	
 
/**
 * Keep only names in the same sentence
 */

create view PersonCorrect as
select PA.person as person
from PersonAll PA
where
-- account for 'all capitalized token' containing hyphens
  	Not(MatchesRegex(/((\p{L}\p{M}*)+\s)?(\p{Lu}\p{M}*){2}((\p{Lu}\p{M}*)|-)+[,\s]+((\p{L}\p{M}*)+\s)?\p{Lu}\p{M}*[\p{Ll}\p{Lo}]\p{M}*.*/, PA.person))
  	and Not(MatchesRegex(/((\p{L}\p{M}*)+\s)?\p{Lu}\p{M}*[\p{Ll}\p{Lo}]\p{M}*.*[,\s]+((\p{L}\p{M}*)+\s)?((\p{Lu}\p{M}*)|-)+/, PA.person))
    and Not(MatchesRegex(/U\.\s*S\.\s*.+/, PA.person))
    and Not(MatchesRegex(/[ ]*['ï¿½][^sld]+/, RightContextTok(PA.person, 2)));


-- to expand person names with suffix
create view PersonCorrectExpanded as
select CombineSpans(P.person,S.suffix) as person
from
	PersonCorrect P,
	PersonSuffix S
where 
	FollowsTok(P.person, S.suffix, 0, 0);	
	

create view PersonCorrectAll as
	(select P.person as person from PersonCorrect P)
	union all
	(select P.person as person from PersonCorrectExpanded P)
	union all 
	(select P.person as person from PersonStrongSingleToken P);


create view PersonSentence as
(select PA.person as person from PersonCorrectAll PA)
minus
(
	select PA.person as person
	from PersonCorrectAll PA, SentenceBoundary S
	where Contains(PA.person, S.boundary)
);  


create view PersonWeak2 as
select P.person as person
from PersonWeak2NoNewLine P
where 
-- do not allow to be part of a list
-- need to make changes if the DOTALL is turned on for MatchesRegex
      Not(MatchesRegex(/(.|\n|\r)*,[ \t]*(\p{Lu}\p{M}*(\p{L}\p{M}*|[-'.])*[ \t]*){0,2}/, LeftContext(P.person, 50)))
  and Not(MatchesRegex(/[ \t]*(\p{Lu}\p{M}*(\p{L}\p{M}*|[-'.])*[ \t]*){0,2}([,&]|(\b(and)[ \t]+))(.|\s)*/, RightContext(P.person, 50)))
-- do not allow to be preceded by greetings
  and Not(ContainsDict('GreetingsDict', LeftContext(P.person, 15)));

-- union all names with pattern (FirstName LastName)
create view PersonFirstNameLastName as
	(select P.person as person from PersonStrong P)
	union all
	(select P.person as person from PersonWeak1 P);

-- remove matches in patterns (LastName, FirstName) that overlaps with patterns in (FirstName LastName)
create view InvalidPersonWeak2 as
select P2.person as person 
from PersonWeak2 P2,
	 PersonFirstNameLastName P1
where Overlaps(P1.person, P2.person);

create view ValidPersonWeak2 as
	(select P.person as person from PersonWeak2 P)
	minus
	(select P.person as person from InvalidPersonWeak2 P);

-- union all valid weak person candidates
create view PersonWeakWithoutNewLine as
	(select P.person as person from PersonWeak1 P)
	union all
	(select P.person as person from ValidPersonWeak2 P);
	
/**
 * Remove matches found by weak rules that also contain new line break
 **/
-- create view PersonWeakWithoutNewLine as
-- select P.person as person
-- from PersonWeak P;
-- where Not(ContainsRegex(/[\n\r]/, P.person));

/**
 * Remove annotations created by relaxed rules overlapping with those
 * generated by stronger rules (e.g., rule 4r1 vs. rule 4) 
 */
create view PersonWeakOverlap as
select P1.person as person
from   PersonWeakWithoutNewLine P1,
       PersonStrong P2
where  Overlaps(P1.person, P2.person);
--	and Not(ContainsRegex(/[\n\r]/, P2.person));

create view PersonWeakOnly as
	(select P.person as person from PersonWeakWithoutNewLine P)
	minus
	(select P.person as person from PersonWeakOverlap P);
  
/**
 * Union all the person names identified by the above rules
 */

create view PersonAll as
	(select P.person as person from PersonWeakOnly P)
union all
	(select P.person as person from PersonStrong P)	
    ;
/*union all
    (select P.firstname as person from FirstName P)
union all
    (select P.lastname as person from LastName P);
    */
/*
    (select P.person as person from Person1 P)
union all  
    (select P.person as person from Person1a P)
union all  
    (select P.person as person from Person3 P)
union all  
    (select P.person as person from Person3r1 P)
union all  
    (select P.person as person from Person3r2 P)
union all  
    (select P.person as person from Person4 P)
union all  
    (select P.person as person from Person4a P)
union all  
    (select P.person as person from Person2 P)
union all  
    (select P.person as person from Person2a P)
union all  
    (select P.person as person from Person4r1 P)
union all  
    (select P.person as person from Person4r2 P)
union all  
    (select P.person as person from Person5 P)
union all  
    (select P.person as person from Person6 P)
union all
    (select P.firstname as person from FirstName P)
union all
    (select P.lastname as person from LastName P);*/
 
 
/**
 * Keep only names in the same sentence
 */

create view PersonCorrect as
select PA.person as person
from PersonAll PA
where
--- start changing this block
--  Not(MatchesRegex(/(\p{Lu}\p{M}*)+[,\s]+\p{Lu}\p{M}*[\p{Ll}\p{Lo}]\p{M}*.*/, PA.person))
--  and Not(MatchesRegex(/\p{Lu}\p{M}*[\p{Ll}\p{Lo}]\p{M}*.*[,\s]+(\p{Lu}\p{M}*)+/, PA.person))
-- change is : account for 'all capitalized token' containing hyphens
--  Not(MatchesRegex(/((\p{Lu}\p{M}*)|-)+[,\s]+\p{Lu}\p{M}*[\p{Ll}\p{Lo}]\p{M}*.*/, PA.person))
--  and Not(MatchesRegex(/\p{Lu}\p{M}*[\p{Ll}\p{Lo}]\p{M}*.*[,\s]+((\p{Lu}\p{M}*)|-)+/, PA.person))
  	Not(MatchesRegex(/((\p{L}\p{M}*)+\s)?(\p{Lu}\p{M}*){2}((\p{Lu}\p{M}*)|-)+[,\s]+((\p{L}\p{M}*)+\s)?\p{Lu}\p{M}*[\p{Ll}\p{Lo}]\p{M}*.*/, PA.person))
  	and Not(MatchesRegex(/((\p{L}\p{M}*)+\s)?\p{Lu}\p{M}*[\p{Ll}\p{Lo}]\p{M}*.*[,\s]+((\p{L}\p{M}*)+\s)?((\p{Lu}\p{M}*)|-)+/, PA.person))
    and Not(MatchesRegex(/U\.\s*S\.\s*.+/, PA.person));
--- end changing this block

-- Yunyao: added 05/09/2008 to expand person names with suffix
create view PersonCorrectExpanded as
select CombineSpans(P.person,S.suffix) as person
from
	PersonCorrect P,
	PersonSuffix S
where 
	FollowsTok(P.person, S.suffix, 0, 0);	
	
create view PersonCorrectAll as
	(select P.person as person from PersonCorrect P)
	union all
	(select P.person as person from PersonCorrectExpanded P);

create view PersonSentence as
(select PA.person as person from PersonCorrectAll PA)
minus
(
	select PA.person as person
	from PersonCorrectAll PA, SentenceBoundary S
	where Contains(PA.person, S.boundary)
);  

/*
create view PersonSentence as
select PA.person as person
from PersonCorrectAll PA,
     sentence S
where Contains(S.sentence, PA.person);  
*/



require document with columns text Text;
-- Capsperson, coco, strictcapsperson, strictcapspersonr, phonenumberinstance, numCP, StreetAddressAll, DotCom,finalPersonAllMatches changed

-- ===========================================================================
-- Date, Time begin here
-- ===========================================================================
--=======================================
-- Date
--
-- 01/31/2008
-- Translated from date.txt by Yunyao Li
-- ======================================

-- Common Macros
 
create view TwoDigitsInterval as
select R.match as match

from RegexTok(/([0123])?[\d]( )*[\-]( )*([0123])?[\d]/, 3,
    Document.text) R; 
 
-- Dictionaries  
 
create view WKDay as
	select
		D.match as match
	from
		Dictionary('dictionaries/wkday.dict', Document.text) D;
		
create view TimeZone as
	select
		D.match as match
	from
		Dictionary('dictionaries/timeZone.dict', Document.text) D;
 

/*
select d.match as match into
AllDates
from Dates d;
*/
-- ========================================================================
-- Time
-- ========================================================================
/*
//CHECKED: This rule will handle time intervals such as  10-11 Sat
<rule annotation=Time id=1>
<internal>
<token attribute={etc}>TWODIGITSINTERVAL</token>
<token attribute={etc}PRD:WKDAY{etc}>ANYWORD</token>
</internal>
</rule>
*/
create view Time1 as
select 
	CombineSpans(td.match, wkd.match) as match
from 
	TwoDigitsInterval td,
	WKDay wkd
where 
	FollowsTok(td.match, wkd.match, 0, 0);

/*
//CHECKED: This rule will handle time intervals such as  Sat 10-11
<rule annotation=Time id=2>
<internal>
<token attribute={etc}PRD:WKDAY{etc}>ANYWORD</token>
<token attribute={etc}>TWODIGITSINTERVAL</token>
</internal>
</rule>
*/
create view Time2 as
select 
	CombineSpans(wkd.match, td.match) as match
from 
	TwoDigitsInterval td,
	WKDay wkd
where 
	FollowsTok(wkd.match, td.match, 0, 0);
	
create view Time2Plus as
select 
	CombineSpans(t.match, tz.match) as match
from 
	Time2 t,
	TimeZone tz
where 
	FollowsTok(t.match, tz.match, 0, 0);

/*
This rule will handle times of the form : 9:00 
<rule annotation=Time id=4>
<internal>
<token attribute={etc}>\d{1,2}\\:\d{2}(\\:\d{2})?</token>
</internal>
</rule>
*/
-- also match 7-9PM
create view Time4 as
select R.match as match
from RegexTok(/(\d{1,2}:\d{2}(:\d{2})?|\d{1,2}-\d{1,2})(\s*[AP])?/, 10, 
    Document.text) R;


/*
//CHECKED: This rule will handle times according to a watch: 9:00 A.M, 9 AM, 9:00 PM
<rule annotation=Time id=3>
<internal>
<token attribute={etc}>[0-9\\:\\.]+</token>
<token attribute={etc}TIMEZONE{etc}>ANYWORD</token>
</internal>
</rule>
*/

create view Time3 as
select 
	CombineSpans(t.match, tz.match) as match
from 
	Regex(/\b\d{1,2}([:.][0-5]\d)?\s*(-\s*\d{1,2}([:.][0-5]\d)?)?\b/, Document.text) t,
	TimeZone tz 
where 
	FollowsTok(t.match, tz.match, 0, 0);	
	
------------------------------------------------------------
-- Union all Times
------------------------------------------------------------
create view TimeAll as
	(select t.match as match from Time1 t)
	union all
	(select t.match as match from Time2 t)
	union all
	(select t.match as match from Time2Plus t)
	union all
	(select t.match as match from Time3 t)
	union all
	(select t.match as match from Time4 t);
	
------------------------------------------------------------
-- Consolidate all Times
------------------------------------------------------------
create view Times as
select R.match as match
--from Consolidate(TimeAll.match) R;
from TimeAll R
consolidate on R.match;

/*
select T.match as match into
AllTimes
from Times T;
*/

  
create dictionary StrongPhoneVariantDictionary as (
	'phone',
 	'cell',
 	'contact',
 	'direct',
	'office',
 	-- Yunyao: Added new strong clues for phone numbers
	'tel',
	'dial',
	'Telefon',
	'mobile',
	'Ph',
	'Phone Number',
	'Direct Line',
	'Telephone No',
	'TTY',
	'Toll Free',
	'Toll-free',
	-- German
	'Fon',
	'Telefon Geschaeftsstelle', 
	'Telefon Geschäftsstelle',
	'Telefon Zweigstelle',
	'Telefon Hauptsitz',
	'Telefon (Geschaeftsstelle)', 
	'Telefon (Geschäftsstelle)',
	'Telefon (Zweigstelle)',
	'Telefon (Hauptsitz)',
	'Telefonnummer',
	'Telefon Geschaeftssitz',
	'Telefon Geschäftssitz',
	'Telefon (Geschaeftssitz)',
	'Telefon (Geschäftssitz)',
	'Telefon Persönlich',
	'Telefon persoenlich',
	'Telefon (Persönlich)',
	'Telefon (persoenlich)',
	'Handy',
	'Handy-Nummer',
	'Telefon arbeit',
	'Telefon (arbeit)'
);


--===========================================================================
-- Sentence annotator
--===========================================================================

-- Dictionary of tokens that, when followed by a punctuation character, are
-- *not* to be treated as sentence boundaries.
create dictionary NotASentenceEnding as
(
	'A.', 'B.', 'C.', 'D.', 'E.', 'F.', 'G.', 'H.', 'I.', 'J.', 'K.', 'L.',
	'M.', 'O.', 'P.', 'Q.', 'R.', 'S.', 'T.', 'U.', 'V.', 'W.', 'X.', 'Y.',
	'Z.',
	
	'Mr.',
	'Mrs.',
	'Dr.',
	'Yahoo!'
);

create view SentenceBoundary as
select R.match as boundary
from Regex(/(([\.\?!]+\s)|(\n\s*\n))/, Document.text) R
where
	-- Filter the candidate boundaries.
	Not(ContainsDict('NotASentenceEnding', 
		CombineSpans(LeftContextTok(R.match, 1), R.match)));
	


-- ===========================================================================
--   Person, Organization, Places begin here 
-- ===========================================================================
 
create dictionary FilterPersonDict as
(
	'Travel', 'Fellow', 'Sir', 'IBMer', 'Researcher', 'All','Tell',
	'Friends', 'Friend', 'Colleague', 'Colleagues', 'Managers','If',
	'Customer', 'Users', 'User', 'Valued', 'Executive', 'Chairs',
	'New', 'Owner', 'Conference', 'Please', 'Outlook', 'Lotus', 'Notes',
	'This', 'That', 'There', 'Here', 'Subscribers', 'What', 'When', 'Where',
	'With', 'While', 'Thanks', 'Thanksgiving','Senator', 'Platinum', 'Perspective',
	'Manager', 'Ambassador', 'Professor', 'Dear', 'Contact', 'Cheers', 'Athelet',
	'And', 'Act', 'But', 'Hello', 'Call', 'From', 'Center', 'The', 'Take', 'Junior',
	'Both', 'Communities', 'Greetings', 'Hope', 'Restaurants', 'Properties',
	'Let', 'Corp', 'Memorial', 'You', 'Your', 'Our',  'My', 'His','Her',
	'Their','Popcorn', 'Name', 'July', 'June','Join',
	'Business', 'Administrative', 'South', 'Members', 'Address', 'Please', 'List',
	'Public', 'Inc', 'Parkway', 'Brother', 'Buy', 'Then', 'Services', 'Statements',
	'President', 'Commissioner', 'Commitment', 'Commits', 'Hey',
	'Director', 'End', 'Exit', 'Experiences', 'Finance', 'Elementary', 'Wednesday',
	'Nov', 'Infrastructure', 'Inside', 'Convention',
	'Judge', 'Lady', 'Friday',  'Project', 'Projected', 
	'Recalls', 'Regards', 'Recently', 'Administration', 'Independence', 'Denied',
	'Unfortunately', 'Under', 'Uncle', 'Utility', 'Unlike', 'Was', 'Were', 'Secretary',
	'Speaker', 'Chairman', 'Consider', 'Consultant', 'County', 'Court', 'Defensive',
	'Northwestern', 'Place', 'Hi', 'Futures', 'Athlete', 'Invitational', 'System',
	'International', 'Main', 'Online', 'Ideally'
	-- more entries
	,'If','Our', 'About', 'Analyst', 'On', 'Of', 'By', 'HR', 'Mkt', 'Pre', 'Post',
	'Condominium', 'Ice', 'Surname', 'Lastname', 'firstname', 'Name', 'familyname',
	-- Italian greeting
   'Ciao',
   -- Spanish greeting
   'Hola',
   -- French greeting
   'Bonjour',
   -- new entries 
   'Pro','Bono','Enterprises','Group','Said','Says','Assistant','Vice','Warden','Contribution',
   'Research', 'Development', 'Product', 'Sales', 'Support', 'Manager', 'Telephone', 'Phone', 'Contact', 'Information',
   'Electronics','Managed','West','East','North','South', 
   'Teaches','Ministry', 'Church', 'Association', 'Laboratories', 'Living', 'Community', 'Visiting',
   'Officer'
);

create dictionary GreetingsDict as
( 
   'Hey', 'Hi', 'Hello', 'Dear',
   -- German greetings
   'Liebe', 'Lieber', 'Herr', 'Frau', 'Hallo', 
   -- Italian
   'Ciao',
   -- Spanish
   'Hola',
   -- French
   'Bonjour'
);
 

 create view USCity as
	select
		D.match as match
	from
		Dictionary('dictionaries/city.dict', 'Exact', Document.text) D;	
  
  create view GermanCities as
	select
		D.match as match 
	from
		Dictionary('dictionaries/city_german.dict', Document.text) D;
  
   create view Country as
	select
		D.match as match
	from
		Dictionary('dictionaries/country.dict', 'Exact', Document.text) D;
  
   create view State  as
	select
		D.match as match
	from
		Dictionary('dictionaries/stateList.dict',  Document.text) D;
	
 
 
-- -----------------------------------------
-- Organization rules begin here
-- ----------------------------------------- 

create dictionary FilterOrgDict as
(
	'Fellow', 'Sir', 'IBMer', 'Researcher','All','Tell','About',
	'Friends', 'Friend', 'Colleague', 'Colleagues','If',
	'Customer', 'Users', 'User', 'Valued', 'Executive', 'Chairs',
	'Please', 'Outlook', 'Notes','Lists', 'Seminar', 'We', 
	'This', 'That', 'There', 'Here', 'Subscribers', 'What', 'When', 'Where',
	'With', 'While', 'Thanks', 'Thanksgiving','Senator', 'Perspective',
	'Manager', 'Professor', 'Dear', 'Contact', 'Cheers', 'Athelet',
	'Act', 'But', 'Hello', 'Call', 'From',  'Take',
	'Both', 'Let', 'You', 'Your', 'Name',
	'Administrative', 'Members', 'Address', 'Please', 'List',
	'Parkway', 'Then', 'Statements', 'Our', 'My', 'His','Her',
	'Their', '\'s Leading',
	'President', 'Commissioner', 'Commitment', 'Commits', 'Hey',
	'Director', 'End', 'Exit', 'Experiences', 'Acquire',
	'Nov', 'Infrastructure', 'Inside', 'Convention', 'Bonus',
	'Judge', 'Projected', 
	'Recalls', 'Regards', 'Recently', 'Independence', 'Denied',
	'Unfortunately', 'Under', 'Secretary','Ideally','Join',
	-- German greetings
	'Liebe', 'Lieber', 'Herr', 'Frau', 'Hi', 'Futures', 'Athlete', 'Invitational',
	'-based',
	-- More added on 02/07/2008
	'Find', 'At','To', 'Copyright'
); 

 
 create dictionary OrgConjDict as
(
	'&','and','und'
);
 
 create dictionary OrgPrepDict as
(
	 'of','for'
);

create dictionary TheDict as
(
	 'The',
	 -- German
	 'Das'
);

create dictionary OrgToAvoidDict as
(	
	'The',
	'Travel',
	'Internal',
	'Betting',
	'Solution',
	'Resolution',
	'West',
	'North',
	'South',
	'East',
	'High',
	'Community',
	'Sunday',
	'Summer',
	'American',
	'Law',
	'Business',
	'Elementary',
	'Middle',
	'Health',
	'Structure',
	'Newly Formed',
	-- added 02/08/2008
	'Luxury'
);

create dictionary OrgPartnershipDict as 
(
	'LP',
	'L.P.',
	'LLP',
	'L.L.P.',
	'LLLP',
	'L.L.L.P.'
);
 
 create view OrgConj as
	select
		D.match as match
	from
		Dictionary('OrgConjDict', Document.text) D;
		
 create view OrgPrep as
	select
		D.match as match
	from
		Dictionary('OrgPrepDict', Document.text) D;
		
 create view The as
	select
		D.match as match
	from
		Dictionary('TheDict', Document.text) D;

create view CapsOrg as
select R.match as match
from RegexTok(/\p{Lu}\p{M}*([\p{Ll}\p{Lo}\&\.'\-\,]\p{M}*)*[\p{Ll}\p{Lo}]/, 10,	
-- '
	Document.text) R
where Not(ContainsDict('dictionaries/industryType_prefix.dict', R.match)); 
	
-- Added 02/08/2008
create view AllCapsOrg as
select R.match as match
from RegexTok(/(\p{Lu}\p{M}*){2,30}/, 1, Document.text) R;		
 
/* 
 create view DotCom as
	select
		R.match as match
	from
		--Regex(/\b[\w\&\-]+\.com\b/, Document.text) R;
		-- Don't allow DOTCOM to be part of a URL
		Regex(/(?<!\.)\b[\w\&\-]+\.com\b(?!\/)/, Document.text) R;

*/

-- Yunyao: changes made to use dictionary
-- start block change
	create dictionary DotComSuffixDict as (
		'.com'
	);
/*
 	create view DotComAnchor as
	select
		R.match as anchor
	from
		--Regex(/\b[\w\&\-]+\.com\b/, Document.text) R;
		-- Don't allow DOTCOM to be part of a URL
		Regex(/\.com\b(?!\/)/, Document.text) R;
*/	

  	create view DotComAnchor as
	select
		D.match as anchor
	from
		Dictionary('DotComSuffixDict', Document.text) D;
	
	create view DotComContext as
    select LeftContextTok(R.anchor,4) as lc, R.anchor as anchor
    from   DotComAnchor R;
 
	create view DotComLC as
    select  R.match  as match 
    from   Regex(/\b[a-zA-Z][\w\&\-]+$/,  DotComContext.lc) R
    where Not(MatchesRegex(/[\.@]/, LeftContextTok(R.match,1)));
    
    create view DotCom as
	select CombineSpans(R1.match,R2.anchor) as match
	from   DotComLC R1, DotComAnchor R2
	where FollowsTok(R1.match, R2.anchor,0,0);

-- end block change
	
/*	
 create view WrongDotCom as
	(select
		R.match as match
	from
		Regex(/\b[\w\&\-]+\.com\b/, Document.text) R)
	minus 
	(select R.match as match from DotCom R);
*/
	 
 --create view OrgClueStInd as
 create view OrgClueStIndCaps as
	select
		D.match as match
	from
		Dictionary('dictionaries/industryType_suffix_weak.dict', 'Exact', Document.text) D;
		
create view OrgClueStIndPrefixCaps as
	select
		D.match as match
	from
		Dictionary('dictionaries/industryType_prefix.dict', 'Exact', Document.text) D;
		
 --create view OrgClueStSuffix as
 create view OrgClueStSuffixCaps as
	select
		D.match as match
	from
		Dictionary('dictionaries/organization_suffix.dict', 'Exact', Document.text) D;
	
		
 create view OrgClueStCaps
 as
	(select OCSIC.match as match from OrgClueStIndCaps OCSIC)
 union all
    (select OCSSC.match as match from OrgClueStSuffixCaps OCSSC);
    
 create view OrgFullCase as
	(select
		D.match as match
	from
		Dictionary('dictionaries/organization_full_case.dict', 'Exact', Document.text) D)
	union all
	(select
		D.match as match
	from
		Dictionary('dictionaries/organization_media.dict', 'Exact', Document.text) D)
	union all
	(select
		D.match as match
	from
		Dictionary('dictionaries/organization_newspaper.dict', 'Exact', Document.text) D);

		
 create view OrgFullNoCase as
	select
		D.match as match
	from
		Dictionary('dictionaries/organization_full_noCase.dict', Document.text) D;
		
		
 create view OrgFull
	as 
	 (select R.match as match from OrgFullNoCase R)
	union all 
	 (select R.match as match from OrgFullCase R);		
   
    create view Coonetotwo as
    select B.block as match
    from BlockTok(0, 1, 2, CapsOrg.match) B;

    create view Coonetothree as
    select B.block as match
    from BlockTok(0, 1, 3, CapsOrg.match) B;
		
-- rule 7
		
	create view CoOcscOpCo as
	select
 		CombineSpans(coco1.match, coco2.match) as match
	from
		Coonetotwo coco1,
		OrgClueStCaps ocsc,
		OrgPrep op,
		Coonetotwo coco2
 	where
		FollowsTok(coco1.match, ocsc.match, 0, 0) and
		FollowsTok(ocsc.match, op.match,0, 0) and
		FollowsTok(op.match, coco2.match, 0, 0);	

-- rule 10

  create view CoOcsic1 as
	select
 		CombineSpans(coco.match, ocsic.match) as match
	from
		Coonetothree coco,
		OrgClueStIndCaps ocsic 
 	where
		FollowsTok(coco.match, ocsic.match, 0, 0);	

 create view CoOcsic2 as
	select
 		CombineSpans(coco.match, ocsic.match) as match
	from
		Coonetothree coco,
 		OrgClueStSuffixCaps ocsic
 	where
		FollowsTok(coco.match, ocsic.match, 0, 0);


create view Continents as
select D.match as match
from   Dictionary('dictionaries/continent.dict', Document.text) D;

create view Nationalities as
select D.match as match
from   Dictionary('dictionaries/nationality.dict', Document.text) D;

create view OrgToAvoid as
select D.match as match
from Dictionary('OrgToAvoidDict', Document.text) D;

create view NonOrgDictMatches as
	(select D.match as match from Continents D)
	union all
	(select D.match as match from Nationalities D)
	union all
	(select D.match as match from Country D)
	union all
	(select D.match as match from State D)
	union all
	(select D.match as match from OrgToAvoid D);

create view NonOrgs as
select CombineSpans(NO.match, OC.match) as match
from   NonOrgDictMatches NO,
 	   OrgClueStCaps OC
where
	FollowsTok(NO.match, OC.match, 0, 1)
	and MatchesRegex(/\s*\W*\s*/, SpanBetween(NO.match, OC.match)); 
	
-- select O.match as match into
-- NonOrgsAll
-- from NonOrgs O;

create view CoOcsicAll as
	(select C.match as match from CoOcsic1 C)
	union all
	(select C.match as match from CoOcsic2 C);

create view CoOcsic as
	(select C.match as match from CoOcsicAll C)
	minus
	(select C.match as match from NonOrgs C);
		
-- rule 10 expansion
	create view CoOcsicEx as
	select CombineSpans(C.match, S.match) as match
	from   CoOcsic1 C,
		   OrgClueStSuffixCaps S,
		   CapsOrg O
	where  FollowsTok(C.match, O.match, 0, 0)
	   and FollowsTok(O.match, S.match, 0, 0);

--rule 9

  create view CoOcsscAll as
	select
 		CombineSpans(coco.match, ocssc.match) as match
	from
		Coonetothree coco,
		OrgClueStSuffixCaps ocssc 
 	where
		FollowsTok(coco.match, ocssc.match, 0, 1) and
		-- ContainsRegex(/^\s*,\s*$/, SpanBetween(coco.match,ocssc.match));
		-- allow cases such as 'Test Test AG' as well		
		MatchesRegex(/\s*[,\s]\s*/, SpanBetween(coco.match,ocssc.match));
		
	create view CoOcssc as
	(select C.match as match from CoOcsscAll C)
	minus
	(select C.match as match from NonOrgs C);
	
-- rule 5
  create view OcscOpCoOcCo as
	select
 		CombineSpans(ocsc.match, coco2.match) as match
	from
		OrgClueStCaps ocsc,
		OrgPrep op,
		Coonetotwo coco1,
		OrgConj oc,
		Coonetotwo coco2
	 	where
			FollowsTok(ocsc.match, op.match, 0, 0) and
			FollowsTok(op.match, coco1.match, 0, 0) and
			FollowsTok(coco1.match, oc.match, 0, 0) and
			FollowsTok(oc.match, coco2.match, 0, 0);
   
   create view CoOcscOpCoOcCo as 
  	  select 
  	  		CombineSpans(coco.match, R1.match) as match
  	  from 
  	  		Coonetotwo coco,
  	  		OcscOpCoOcCo R1
  	  where 
  	  		FollowsTok(coco.match,R1.match,0,0);
		
 
-- R1

	create view OfCo as
		select 
			CombineSpans(of.match,coco.match) as match
		from
			OrgFull of,
			Coonetotwo coco
		where
			FollowsTok(of.match,coco.match,0,0);
	  	  		
	 create view OfCozerototwo as
	 	(select R.match as match from OrgFull R)
	 union all
	    (select R.match as match from OfCo R);
	    
	 create view OfCoOcsc as
	     select
	     	CombineSpans(of.match,ocsc.match) as match
	     from
	     	OfCozerototwo of,
	     	OrgClueStCaps ocsc
	     where
	     	FollowsTok(of.match,ocsc.match,0,0);
	     	
-- R2

	create view CoOc as
	     select
	     	CombineSpans(co.match,oc.match) as match
	     from
	     	Coonetotwo co,
	     	OrgConj oc
	     where
	     	FollowsTok(co.match,oc.match,0,0);
	     	
	create view CoOcCo as
	     select
	     	CombineSpans(cooc.match,co.match) as match
	     from
	     	CoOc cooc,
	     	Coonetotwo co
	     where
	     	FollowsTok(cooc.match,co.match,0,0);

	create view CoOcCozerototwo as
		(select R.match as match from CoOc R)
	union all 
		(select R.match as match from CoOcCo R); 

	create view CoOcCozerototwoOcscOpCo as
		select
	     	CombineSpans(coocco.match,co.match) as match
	     from
	     	CoOcCozerototwo coocco,
	     	OrgClueStCaps ocsc,
	     	OrgPrep op,
	     	Coonetotwo co
	     where
	     	FollowsTok(coocco.match, ocsc.match,0,0) and
	     	FollowsTok(ocsc.match,op.match,0,0) and
	     	FollowsTok(op.match,co.match,0,0);
	     	
-- R11
-- Added by Yunyao Li to support organization names such as 'the University of Washington' etc
create view OrganizationR11_no_quantifier as
select CombineSpans(OP.match, CO.block) as match
from BlockTok(0, 1, 3, CapsOrg.match) CO,
     OrgPrep P,
     OrgClueStIndPrefixCaps OP
where FollowsTok(OP.match, P.match, 0, 0)
  and FollowsTok(P.match, CO.block, 0, 0)
  -- do not allow new line
  and Not(ContainsRegex(/[\n\r]/, CombineSpans(OP.match, CO.block)));

/*
create view NonOrgQuantifier as
select CO.block as match	
from BlockTok(0, 1, 3, CapsOrg.match) CO,
	 OrganizationR11_no_quantifier O
where Overlaps(CO.block, O.match);
 
create view OrgQuantifier as
	(select B.block as match from BlockTok(0, 1, 3, CapsOrg.match) B)
    minus
    (select B.match as match from NonOrgQuantifier B);
    
select Q.match as match into
OrgQuantifiers
from OrgQuantifier Q;

select Q.match as match into
NonOrgQuantifiers
from NonOrgQuantifier Q;
*/

create view OrganizationR11_with_quantifier as
select CombineSpans(CO.block, O.match) as match	
from BlockTok(0, 1, 3, CapsOrg.match) CO,
	 OrganizationR11_no_quantifier O
where FollowsTok(CO.block, O.match, 0, 0);

create view OrganizationR11_no_the as 
 	(select O.match as match from OrganizationR11_no_quantifier O)
union all
	(select O.match as match from OrganizationR11_with_quantifier O);
	
-- R5, R7, R9, R10, R11
 
 	create view Org5791011	
	as 
	 (select R.match as match from  CoOcscOpCoOcCo R)
	union all 
	 (select R.match as match from OcscOpCoOcCo R)
	union all 
	 (select R.match as match from  CoOcsic R)
	union all 
	 (select R.match as match from CoOcssc R)
	union all 
	 (select R.match as match from  CoOcscOpCo R)
	union all
	 (select R.match as match from  OrganizationR11_no_the R)
	union all
	 (select R.match as match from CoOcsicEx R)
	 ;
		
	-- added 02/08/2008
	 create view ExpandedOrg5791011 as
	 	select
			CombineSpans(ab.match, org5791011.match) as match
  	  from 
  	  		AllCapsOrg  ab,
  	  		Org5791011 org5791011
  	  where 
  	  		FollowsTok(ab.match,org5791011.match,0,0) and
  	  		Not(ContainsRegex(/[\n\r]/, SpanBetween(ab.match,org5791011.match)));
	
	 --create view TheOrg57910 as
	 create view TheOrg5791011 as  
  	  select 
  	  		CombineSpans(the.match, org5791011.match) as match
  	  from 
  	  		The  the,
  	  		Org5791011 org5791011
  	  where 
  	  		FollowsTok(the.match,org5791011.match,0,0);
  	  		

	-- ===========================================================================
-- >>>>>>>>>>>>>>> Aggregation/Consolidation section <<<<<<<<<<<<<<<<
-- ===========================================================================

-- Merge all the different rules.
create view OrgAll as
	 (select R.match as org from DotCom R)
union all 
	 (select R.match as org from OrgFull R)
union all
	 (select R.match as org from Org5791011 R)
union all
	 (select R.match as org from TheOrg5791011 R)
union all
	 (select R.match as org from ExpandedOrg5791011 R)
union all
     (select R.match as org from OfCoOcsc R)
union all 
	 (select R.match as org from CoOcCozerototwoOcscOpCo R);
	
-- ------------------------------------------
-- Consolidation:
-- For now, we just remove annotations that are completely
-- contained within other annotations.

create view OrgSentence as
(
	select OA.org as org	 
	from OrgAll OA
	where
		-- do not allow new line
        Not(ContainsRegex(/[\n\r]/, OA.org))
        and Not(ContainsDict('FilterOrgDict', OA.org))
        and Not(ContainsDict('dictionaries/filterOrg_german.dict', OA.org))		
		--and Not(ContainsDict('dictionaries/industry_types_prefix.dict',OA.org))
)
minus
(
	select OA.org as org	 
	from SentenceBoundary S, OrgAll OA
	where Contains(OA.org, S.boundary)
);

 -- -----------------------------------------
-- Person rules begin here
-- ----------------------------------------- 
  
create dictionary InitialDict as
(
	'rev.', 'col.', 'reverend', 'prof.', 'professor.', 
	'lady', 'miss.', 'mrs.', 'mrs', 'mr.', 'pt.', 'ms.',
	'messrs.', 'dr.', 'master.', 'marquis', 'monsieur',
	'ds', 'di'
	--'Dear' (Yunyao: comments out to avoid mismatches such as Dear Member),
	--'Junior' (Yunyao: comments out to avoid mismatches such as Junior National [team player],
 	-- If we can have large negative dictionary to eliminate such mismatches, 
	-- then this may be recovered 
	--'Name:' ((Yunyao: comments out to avoid mismatches such as 'Name: Last Name')
	-- for German names
	-- TODO: need further test
	,'herr', 'Fraeulein', 'Doktor', 'Herr Doktor', 'Frau Doktor',
	'Herr Professor', 'Frau professor', 'Baron', 'graf'
);

-- Find dictionary matches for all title initials
create view Initial as
select D.match as initial
from   Dictionary('InitialDict', Document.text) D;

-- Find capitalized words that look like person  names and not in the non-name dictionary
create view CapsPerson as
select R.match as name
from 
	RegexTok(
		/\p{Lu}\p{M}*(\p{L}\p{M}*){0,10}(['\-][\p{Lu}\p{M}*])?(\p{L}\p{M}*){1,10}/,
		--'
		3, Document.text) R
where  Not(ContainsDicts(
            'FilterPersonDict', 
            'dictionaries/filterPerson_german.dict',
            'InitialDict',
            'StrongPhoneVariantDictionary',
            'dictionaries/stateList.dict',
            'dictionaries/organization_suffix.dict',
            --'dictionaries/industry_types_retained.dict',
            'dictionaries/streetSuffix_forPerson.dict', R.match))
   and Not(MatchesRegex(/(\p{Lu}\p{M}*)+-.*([\p{Ll}\p{Lo}]\p{M}*).*/, R.match))
   and Not(MatchesRegex(/.*([\p{Ll}\p{Lo}]\p{M}*).*-(\p{Lu}\p{M}*)+/, R.match));


-- Find strict capitalized words with two letter or more  (relaxed version of StrictCapsPerson)

--============================================================
--TODO: need to think through how to deal with hypened name 
-- one way to do so is to run Regex(pattern, CP.name) and enforce CP.name does not contain '
-- need more testing before confirming the change

create view CapsPersonNoP as
select CP.name as name
from CapsPerson CP
where Not(ContainsRegex(/'/, CP.name)); -- '

create view StrictCapsPersonR as
select R.match as name
from Regex(/\p{Lu}\p{M}*(\p{L}\p{M}*){1,20}/, CapsPersonNoP.name) R;

--============================================================

--create view StrictCapsPersonRO as
--select R.match as name
--from   Regex(/\b\p{Lu}\p{M}*(\p{L}\p{M}*){1,20}\b/, Document.text) R
/*where  Not(ContainsDicts(
		'FilterPersonDict',
		'dictionaries/filterPersonGerman.dict',
		'InitialDict',
		'StrongPhoneVariantDictionary',
		'dictionaries/Statelist.dict',
		'dictionaries/organization_suffixes.dict',
   		'dictionaries/industry_types_retained.dict', 
   		'dictionaries/streetSuffixesForPerson.dict', R.match));
*/
		
-- Find strict capitalized words
--create view StrictCapsPerson as
create view StrictCapsPerson as
select R.name as name
from StrictCapsPersonR R
where MatchesRegex(
    /\p{Lu}\p{M}*[\p{Ll}\p{Lo}]\p{M}*(\p{L}\p{M}*){1,20}/, R.name);

-- Find dictionary matches for all last names
create view StrictLastName1 as
select D.match as lastname
from   Dictionary('dictionaries/strictlast.dict', Document.text) D
--where  MatchesRegex(/\p{Upper}\p{Lower}[\p{Alpha}]{0,20}/, D.match);	
-- changed to enable unicode match
where  MatchesRegex(/((\p{L}\p{M}*)+\s+)?\p{Lu}\p{M}*.{1,20}/, D.match);	

create view StrictLastName2 as
select D.match as lastname
from   Dictionary('dictionaries/strictLast_german.dict', Document.text) D
--where  MatchesRegex(/\p{Upper}\p{Lower}[\p{Alpha}]{0,20}/, D.match);	
--where  MatchesRegex(/\p{Upper}.{1,20}/, D.match);
-- changed to enable unicode match
where  MatchesRegex(/((\p{L}\p{M}*)+\s+)?\p{Lu}\p{M}*.{1,20}/, D.match);	

create view StrictLastName3 as
select D.match as lastname
from   Dictionary('dictionaries/strictLast_german_bluePages.dict', Document.text) D
--where  MatchesRegex(/\p{Upper}\p{Lower}[\p{Alpha}]{0,20}/, D.match);	
--where  MatchesRegex(/\p{Upper}.{1,20}/, D.match);
-- changed to enable unicode match
where  MatchesRegex(/((\p{L}\p{M}*)+\s+)?\p{Lu}\p{M}*.{1,20}/, D.match);

create view StrictLastName4 as
select D.match as lastname
from   Dictionary('dictionaries/uniqMostCommonSurname.dict', Document.text) D
--where  MatchesRegex(/\p{Upper}\p{Lower}[\p{Alpha}]{0,20}/, D.match);	
--where  MatchesRegex(/\p{Upper}.{1,20}/, D.match);
-- changed to enable unicode match
where  MatchesRegex(/((\p{L}\p{M}*)+\s+)?\p{Lu}\p{M}*.{1,20}/, D.match);

create view StrictLastName as
	(select S.lastname as lastname from StrictLastName1 S)
	union all
	(select S.lastname as lastname from StrictLastName2 S)
	union all
	(select S.lastname as lastname from StrictLastName3 S)
	union all
	(select S.lastname as lastname from StrictLastName4 S);

-- Relaxed version of last name
create view RelaxedLastName1 as
select CombineSpans(SL.lastname, CP.name) as lastname
from StrictLastName SL,
     StrictCapsPerson CP
where FollowsTok(SL.lastname, CP.name, 1, 1)
  and MatchesRegex(/\-/, SpanBetween(SL.lastname, CP.name));

create view RelaxedLastName2 as
select CombineSpans(CP.name, SL.lastname) as lastname
from StrictLastName SL,
     StrictCapsPerson CP
where FollowsTok(CP.name, SL.lastname, 1, 1)
  and MatchesRegex(/\-/, SpanBetween(CP.name, SL.lastname));

-- all the last names
create view LastNameAll as
	(select N.lastname as lastname from StrictLastName N)
	union all
	(select N.lastname as lastname from RelaxedLastName1 N)
	union all
	(select N.lastname as lastname from RelaxedLastName2 N);

create view ValidLastNameAll as
select N.lastname as lastname
from LastNameAll N
-- do not allow partially all capitalized words
where Not(MatchesRegex(/(\p{Lu}\p{M}*)+-.*([\p{Ll}\p{Lo}]\p{M}*).*/, N.lastname))
  and Not(MatchesRegex(/.*([\p{Ll}\p{Lo}]\p{M}*).*-(\p{Lu}\p{M}*)+/, N.lastname));
	
create view LastName as
select C.lastname as lastname
--from Consolidate(ValidLastNameAll.lastname) C;
from ValidLastNameAll C
consolidate on C.lastname;

-- Find dictionary matches for all first names
-- Mostly US first names
create view StrictFirstName1 as
select D.match as firstname
from   Dictionary('dictionaries/strictfirst.dict', Document.text) D
--where  MatchesRegex(/\p{Upper}\p{Lower}[\p{Alpha}]{0,20}/, D.match);	
-- changed to enable unicode match
where  MatchesRegex(/\p{Lu}\p{M}*.{1,20}/, D.match);	

-- German first names
create view StrictFirstName2 as
select D.match as firstname
from   Dictionary('dictionaries/strictFirst_german.dict', Document.text) D
--where  MatchesRegex(/\p{Upper}\p{Lower}[\p{Alpha}]{0,20}/, D.match);	
--where  MatchesRegex(/\p{Upper}.{1,20}/, D.match);
-- changed to enable unicode match
where  MatchesRegex(/\p{Lu}\p{M}*.{1,20}/, D.match);	

-- nick names for US first names
create view StrictFirstName3 as
select D.match as firstname
from   Dictionary('dictionaries/strictNickName.dict', Document.text) D
--where  MatchesRegex(/\p{Upper}\p{Lower}[\p{Alpha}]{0,20}/, D.match);	
--where  MatchesRegex(/\p{Upper}.{1,20}/, D.match);
-- changed to enable unicode match
where  MatchesRegex(/\p{Lu}\p{M}*.{1,20}/, D.match);

-- german first name from blue page
create view StrictFirstName4 as
select D.match as firstname
from   Dictionary('dictionaries/strictFirst_german_bluePages.dict', Document.text) D
--where  MatchesRegex(/\p{Upper}\p{Lower}[\p{Alpha}]{0,20}/, D.match);	
--where  MatchesRegex(/\p{Upper}.{1,20}/, D.match);
-- changed to enable unicode match
where  MatchesRegex(/\p{Lu}\p{M}*.{1,20}/, D.match);	

/* TODO: add all the other international names
-- UK first name from blue pages
create view StrictFirstName5 as
select D.match as firstname
from   Dictionary('dictionaries/server/firstNames_uk_bp_over5.dict', Document.text) D
where  MatchesRegex(/\p{Lu}\p{M}*.{1,20}/, D.match);	
*/

-- union all the dictionary matches for first names
create view StrictFirstName as
	(select S.firstname as firstname from StrictFirstName1 S)
	union all
	(select S.firstname as firstname from StrictFirstName2 S)
	union all
	(select S.firstname as firstname from StrictFirstName3 S)
	union all
	(select S.firstname as firstname from StrictFirstName4 S);

-- Relaxed versions of first name
create view RelaxedFirstName1 as
select CombineSpans(S.firstname, CP.name) as firstname
from StrictFirstName S,
     StrictCapsPerson CP
where FollowsTok(S.firstname, CP.name, 1, 1)
  and MatchesRegex(/\-/, SpanBetween(S.firstname, CP.name));

create view RelaxedFirstName2 as
select CombineSpans(CP.name, S.firstname) as firstname
from StrictFirstName S,
     StrictCapsPerson CP
where FollowsTok(CP.name, S.firstname, 1, 1)
  and MatchesRegex(/\-/, SpanBetween(CP.name, S.firstname));
  
-- all the first names
create view FirstNameAll as
	(select N.firstname as firstname from StrictFirstName N)
	union all
	(select N.firstname as firstname from RelaxedFirstName1 N)
	union all
	(select N.firstname as firstname from RelaxedFirstName2 N);

create view ValidFirstNameAll as
select N.firstname as firstname
from FirstNameAll N
where Not(MatchesRegex(/(\p{Lu}\p{M}*)+-.*([\p{Ll}\p{Lo}]\p{M}*).*/, N.firstname))
  and Not(MatchesRegex(/.*([\p{Ll}\p{Lo}]\p{M}*).*-(\p{Lu}\p{M}*)+/, N.firstname));
	
create view FirstName as
select C.firstname as firstname
--from Consolidate(ValidFirstNameAll.firstname) C;
from ValidFirstNameAll C
consolidate on C.firstname;

-- Combine all dictionary matches for both last names and first names
create view NameDict as
select D.match as name
from   Dictionary('dictionaries/name.dict', Document.text) D
--where  MatchesRegex(/\p{Upper}\p{Lower}[\p{Alpha}]{0,20}/, D.match);	
--where  MatchesRegex(/\p{Upper}.{1,20}/, D.match);	
-- changed to enable unicode match
where  MatchesRegex(/\p{Lu}\p{M}*.{1,20}/, D.match);	

create view NamesAll as
	(select P.name as name from NameDict P)
	union all
	(select P.firstname as name from FirstName P)
	union all
	(select P.lastname as name from LastName P);
	
create view PersonDict as
select C.name as name
--from Consolidate(NamesAll.name) C;
from NamesAll C
consolidate on C.name;

-- Find initial words 
create view InitialWord as
select R.match as word
from RegexTok(/([\p{Upper}]\.\s*){0,4}[\p{Upper}]\./, 10, Document.text) R;

-- Find weak initial words 
create view WeakInitialWord as
select R.match as word
from RegexTok(/([\p{Upper}]\.?\s*){1,5}/, 12, Document.text) R;

--==========================================================
-- Actual Rules
--==========================================================

-- For 3-part Person names
create view Person3P1 as 
select CombineSpans(F.firstname, L.lastname) as person
from StrictFirstName F,
	 StrictCapsPersonR S,
	 StrictLastName L
where FollowsTok(F.firstname, S.name, 0, 0)
 and  FollowsTok(S.name, L.lastname, 0, 0)
 and  Not(Equals(GetText(F.firstname), GetText(L.lastname)))
 and  Not(Equals(GetText(F.firstname), GetText(S.name)))
 and  Not(Equals(GetText(S.name), GetText(L.lastname)))
 and  Not(ContainsRegex(/[\n\r\t]/, SpanBetween(F.firstname, L.lastname)));
 
create view Person3P2 as 
select CombineSpans(P.name, L.lastname) as person
from PersonDict P,
	 StrictCapsPersonR S,
	 StrictLastName L
where FollowsTok(P.name, S.name, 0, 0)
 and  FollowsTok(S.name, L.lastname, 0, 0)
 and  Not(Equals(GetText(P.name), GetText(L.lastname)))
 and  Not(Equals(GetText(P.name), GetText(S.name)))
 and  Not(Equals(GetText(S.name), GetText(L.lastname)))
 and  Not(ContainsRegex(/[\n\r\t]/, SpanBetween(P.name, L.lastname)));

create view Person3P3 as 
select CombineSpans(F.firstname, P.name) as person
from PersonDict P,
	 StrictCapsPersonR S,
	 StrictFirstName F
where FollowsTok(S.name, P.name, 0, 0)
 and  FollowsTok(F.firstname, S.name, 0, 0)
 and  Not(Equals(GetText(P.name), GetText(F.firstname)))
 and  Not(Equals(GetText(P.name), GetText(S.name)))
 and  Not(Equals(GetText(S.name), GetText(F.firstname)))
 and  Not(ContainsRegex(/[\n\r\t]/, SpanBetween(F.firstname, P.name)));

/**
 * Translation for Rule 1
 * Handles names of persons like Mr. Vladimir E. Putin
 */
/*
<rule annotation=Person id=1>
<token attribute={etc}INITIAL{etc}>CANYWORD</token>
<internal>
<token attribute={etc}>CAPSPERSON</token>
<token attribute={etc}>INITIALWORD</token>
<token attribute={etc}>CAPSPERSON</token>
</internal>
</rule>
*/
 
 create view Person1 as
 select CombineSpans(CP1.name, CP2.name) as person
 from   Initial I,
        CapsPerson CP1,
        InitialWord IW,
        CapsPerson CP2
 where  FollowsTok(I.initial, CP1.name, 0, 0)
   and  FollowsTok(CP1.name, IW.word, 0, 0)
   and  FollowsTok(IW.word, CP2.name, 0, 0);
   --and  Not(ContainsRegex(/[\n\r]/, SpanBetween(I.initial, CP2.name)));
 
/**
 * Translation for Rule 1a
 * Handles names of persons like Mr. Vladimir Putin
 */
/* 
<rule annotation=Person id=1a>
<token attribute={etc}INITIAL{etc}>CANYWORD</token>
<internal>
<token attribute={etc}>CAPSPERSON</token>{1,3}
</internal>
</rule>*/

 -- Split into two rules so that single token annotations are serperated from others
 -- Single token annotations
 create view Person1a as
 select CP1.name as person
 from   Initial I,
        CapsPerson CP1
 where  FollowsTok(I.initial, CP1.name, 0, 0)
 --- start changing this block
--- disallow allow newline 
 and Not(ContainsRegex(/[\n\t]/,SpanBetween(I.initial,CP1.name)))
--- end changing this block
;
 
 create view Person1a_more as 
 select name.block as person
 from   Initial I,
        BlockTok(0, 2, 3, CapsPerson.name) name
 where  FollowsTok(I.initial, name.block, 0, 0)
	and Not(ContainsRegex(/[\n\t]/,name.block))
--- start changing this block
-- disallow newline
 and Not(ContainsRegex(/[\n\t]/,SpanBetween(I.initial,name.block)))
--- end changing this block
	;

/**
 * Translation for Rule 3
 * Find person names  like Thomas B.M. David
 */
 /*
<rule annotation=Person id=3>
<internal>
<token attribute={etc}PERSON{etc}>CAPSPERSON</token>
<token attribute={etc}>INITIALWORD</token>
<token attribute={etc}PERSON{etc}>CAPSPERSON</token>
</internal>
</rule>*/

 create view Person3 as
 select CombineSpans(P1.name, P2.name) as person
 from   PersonDict P1,
        --InitialWord IW,
        WeakInitialWord IW,
        PersonDict P2
 where  FollowsTok(P1.name, IW.word, 0, 0)
   and  FollowsTok(IW.word, P2.name, 0, 0);
 
 /**
 * Translation for Rule 3r1
 * 
 * This relaxed version of rule '3' will find person names  like Thomas B.M. David
 * But it only insists that the first word is in the person dictionary
 */
 /*
<rule annotation=Person id=3r1>
<internal>
<token attribute={etc}PERSON:ST:FNAME{etc}>CAPSPERSON</token>
<token attribute={etc}>INITIALWORD</token>
<token attribute={etc}>CAPSPERSON</token>
</internal>
</rule>
*/

create view Person3r1 as
 select CombineSpans(FN.firstname, CP.name) as person
 from   FirstName FN,
        InitialWord IW,
        CapsPerson CP
 where  FollowsTok(FN.firstname, IW.word, 0, 0)
   and  FollowsTok(IW.word, CP.name, 0, 0);

/**
 * Translation for Rule 3r2
 * 
 * This relaxed version of rule '3' will find person names  like Thomas B.M. David
 * But it only insists that the second word is in the person dictionary
 */
/*
<rule annotation=Person id=3r2>
<internal>
<token attribute={etc}>CAPSPERSON</token>
<token attribute={etc}>INITIALWORD</token>
<token attribute={etc}PERSON:ST:LNAME{etc}>CAPSPERSON</token>
</internal>
</rule>*/

create view Person3r2 as
select CombineSpans(CP.name, LN.lastname) as person
from   LastName LN,
       InitialWord IW,
       CapsPerson CP
where  FollowsTok(CP.name, IW.word, 0, 0)
  and  FollowsTok(IW.word, LN.lastname, 0, 0);

/**
 * Translation for Rule 4
 *
 * This rule will find person names  like David Thomas
 */
 /*
 <rule annotation=Person id=4>
<internal>
<token attribute={etc}PERSON:ST:FNAME{etc}>CAPSPERSON</token>
<token attribute={etc}PERSON:ST:LNAME{etc}>CAPSPERSON</token>
</internal>
</rule>
*/
create view Person4WithNewLine as
select CombineSpans(FN.firstname, LN.lastname) as person
from   FirstName FN,
       LastName LN
where  FollowsTok(FN.firstname, LN.lastname, 0, 0);

create view Person4Wrong as
select CombineSpans(FN.firstname, LN.lastname) as person
from   FirstName FN,
       LastName LN
where  FollowsTok(FN.firstname, LN.lastname, 0, 0)
   and ContainsRegex(/[\n\r]/, SpanBetween(FN.firstname, LN.lastname))
   and Equals(GetText(FN.firstname), GetText(LN.lastname)); 
   
create view Person4 as
	(select P.person as person from Person4WithNewLine P)
	minus
	(select P.person as person from Person4Wrong P); 
   
/**
 * Translation for Rule4a
 * This rule will find person names  like Thomas, David
 */
 /*
<rule annotation=Person id=4a>
<internal>
<token attribute={etc}PERSON:ST:LNAME{etc}>CAPSPERSON</token>
<token attribute={etc}>\,</token>
<token attribute={etc}PERSON:ST:FNAME{etc}>CAPSPERSON</token>
</internal>
</rule>
 */
create view Person4a as
select CombineSpans(LN.lastname, FN.firstname) as person
from   FirstName FN,
       LastName LN
where  FollowsTok(LN.lastname, FN.firstname, 0, 1)
and   ContainsRegex(/,/,SpanBetween(LN.lastname, FN.firstname)); 
 
-- relaxed version of Rule4a
create view Person4ar1 as
select CombineSpans(CP.name, FN.firstname) as person
from   FirstName FN,
       CapsPerson CP
where  FollowsTok(CP.name, FN.firstname, 0, 1)
and   ContainsRegex(/,/,SpanBetween(CP.name, FN.firstname))
and   Not(MatchesRegex(/(.|\n|\r)*(\.|\?|!|'|\sat|\sin)( )*/, LeftContext(CP.name, 10)))
and   Not(MatchesRegex(/(?i)(.+fully)/, CP.name))
and   GreaterThan(GetBegin(CP.name), 10);

create view Person4ar2 as
select CombineSpans(LN.lastname, CP.name) as person
from   CapsPerson CP,
       LastName LN
where  FollowsTok(LN.lastname, CP.name, 0, 1)
and   ContainsRegex(/,/,SpanBetween(LN.lastname, CP.name));

 
/**
 * Translation for Rule2
 *
 * This rule will handles names of persons like B.M. Thomas David, where Thomas occurs in some person dictionary
 */
 /*
<rule annotation=Person id=2>
<internal>
<token attribute={etc}>INITIALWORD</token>
<token attribute={etc}PERSON{etc}>CAPSPERSON</token>
<token attribute={etc}>CAPSPERSON</token>
</internal>
</rule>
*/

create view Person2 as
select CombineSpans(IW.word, CP.name) as person
from   InitialWord IW,
       PersonDict P,
       CapsPerson CP
where  FollowsTok(IW.word, P.name, 0, 0)
  and  FollowsTok(P.name, CP.name, 0, 0);

/**
 * Translation for Rule 2a
 *
 * The rule handles names of persons like B.M. Thomas David, where David occurs in some person dictionary
 */
/*
<rule annotation=Person id=2a>
<internal>
<token attribute={etc}>INITIALWORD</token>
<token attribute={etc}>CAPSPERSON</token>
<token attribute={etc}>NEWLINE</token>?
<token attribute={etc}PERSON{etc}>CAPSPERSON</token>
</internal>
</rule>
*/

create view Person2a as
select CombineSpans(IW.word, P.name) as person
from   InitialWord IW,
	   CapsPerson CP,
       PersonDict P
where  FollowsTok(IW.word, CP.name, 0, 0)
  and  FollowsTok(CP.name, P.name, 0, 0);


/**
 * Translation for Rule 4r1
 * This relaxed version of rule '4' will find person names  Thomas, David
 * But it only insists that the FIRST word is in some person dictionary
 */
/*
<rule annotation=Person id=4r1>
<internal>
<token attribute={etc}PERSON:ST:FNAME{etc}>CAPSPERSON</token>
<token attribute={etc}>NEWLINE</token>?
<token attribute={etc}>CAPSPERSON</token>
</internal>
</rule>
*/
create view Person4r1 as
select CombineSpans(FN.firstname, CP.name) as person
from   FirstName FN,
	   CapsPerson CP
where  FollowsTok(FN.firstname, CP.name, 0, 0);
  

/**
 * Translation for Rule 4r2
 *
 * This relaxed version of rule '4' will find person names  Thomas, David
 * But it only insists that the SECOND word is in some person dictionary
 */
 /*
<rule annotation=Person id=4r2>
<token attribute={etc}>ANYWORD</token>
<internal>
<token attribute={etc}>CAPSPERSON</token>
<token attribute={etc}>NEWLINE</token>?
<token attribute={etc}PERSON:ST:LNAME{etc}>CAPSPERSON</token>
</internal>
</rule>
*/
create view Person4r2 as
select CombineSpans(CP.name, LN.lastname) as person
from   CapsPerson CP,
       LastName LN
where  FollowsTok(CP.name, LN.lastname, 0, 0);


/**
 * Translation for Rule 5
 *
 * This rule will find other single token person first names
 */
 /* 
<rule annotation=Person id=5>
<internal>
<token attribute={etc}>INITIALWORD</token>?
<token attribute={etc}PERSON:ST:FNAME{etc}>CAPSPERSON</token>
</internal>
</rule>
*/
create view Person5 as
select CombineSpans(IW.word, FN.firstname) as person
from   InitialWord IW,
       FirstName FN
where  FollowsTok(IW.word, FN.firstname, 0, 0);


/**
 * Translation for Rule 6
 *
 * This rule will find other single token person last names
 */
 /* 
<rule annotation=Person id=6>
<internal>
<token attribute={etc}>INITIALWORD</token>?
<token attribute={etc}PERSON:ST:LNAME{etc}>CAPSPERSON</token>
</internal>
</rule>
*/

create view Person6 as
select CombineSpans(IW.word, LN.lastname) as person
from   InitialWord IW,
       LastName LN
where  FollowsTok(IW.word, LN.lastname, 0, 0);

--==========================================================
-- End of rules
--
-- Create final list of names based on all the matches extracted
--
--==========================================================

/**
 * Union all matches found by strong rules, except the ones directly come
 * from dictionary matches
 */
create view PersonStrongWithNewLine as
	(select P.person as person from Person1 P)
union all  
    (select P.person as person from Person1a_more P)
union all  
    (select P.person as person from Person3 P)
union all  
    (select P.person as person from Person4 P)
union all
	(select P.person as person from Person3P1 P);
	
-- remove entries with new lines per Brian's request	
create view PersonStrong as
select P.person as person
from PersonStrongWithNewLine P
where Not(ContainsRegex(/[\n\r]/, P.person));
    
create view PersonStrongSingleToken as  
    (select P.person as person from Person5 P)
union all  
    (select P.person as person from Person6 P)
union all
    (select P.firstname as person from FirstName P)
union all
    (select P.lastname as person from LastName P)
union all  
    (select P.person as person from Person1a P);
 

/**
 * Union all matches found by weak rules
 */
create view PersonWeak1WithNewLine as  
	(select P.person as person from Person3r1 P)
union all  
    (select P.person as person from Person3r2 P)
union all
	(select P.person as person from Person4r1 P)
union all  
    (select P.person as person from Person4r2 P)
union all  
	(select P.person as person from Person2 P)
union all  
    (select P.person as person from Person2a P)
union all
	(select P.person as person from Person3P2 P)
union all
	(select P.person as person from Person3P3 P);
	
create view PersonWeak1 as
select P.person as person
from PersonWeak1WithNewLine P
where Not(ContainsRegex(/[\n\r]/, P.person));
	
-- weak rules that identify (LastName, FirstName)
create view PersonWeak2WithNewLine as
    (select P.person as person from Person4a P)
union all 
    (select P.person as person from Person4ar1 P)
union all
    (select P.person as person from Person4ar2 P);

create view PersonWeak2 as
select P.person as person
from PersonWeak2WithNewLine P
where Not(ContainsRegex(/[\n\r]/, P.person))
-- do not allow to be part of a list
-- need to make changes if the DOTALL is turned on for MatchesRegex
  and Not(MatchesRegex(/(.|\n|\r)*,[ \t]*(\p{Lu}\p{M}*(\p{L}\p{M}*|[-'.])*[ \t]*){0,2}/, LeftContext(P.person, 50)))
  and Not(MatchesRegex(/[ \t]*(\p{Lu}\p{M}*(\p{L}\p{M}*|[-'.])*[ \t]*){0,2}([,&]|(\b(and)[ \t]+))(.|\s)*/, RightContext(P.person, 50)))
-- do not allow to be preceded by greetings
  and Not(ContainsDict('GreetingsDict', LeftContext(P.person, 15)));

-- union all names with pattern (FirstName LastName)
create view PersonFirstNameLastName as
	(select P.person as person from PersonStrong P)
	union all
	(select P.person as person from PersonWeak1 P);

-- remove matches in patterns (LastName, FirstName) that overlaps with patterns in (FirstName LastName)
create view InvalidPersonWeak2 as
select P2.person as person 
from PersonWeak2 P2,
	 PersonFirstNameLastName P1
where Overlaps(P1.person, P2.person);

create view ValidPersonWeak2 as
	(select P.person as person from PersonWeak2 P)
	minus
	(select P.person as person from InvalidPersonWeak2 P);

-- union all valid weak person candidates
create view PersonWeakWithoutNewLine as
	(select P.person as person from PersonWeak1 P)
	union all
	(select P.person as person from ValidPersonWeak2 P);
	
/**
 * Remove matches found by weak rules that also contain new line break
 **/
-- create view PersonWeakWithoutNewLine as
-- select P.person as person
-- from PersonWeak P;
-- where Not(ContainsRegex(/[\n\r]/, P.person));

/**
 * Remove annotations created by relaxed rules overlapping with those
 * generated by stronger rules (e.g., rule 4r1 vs. rule 4) 
 */
create view PersonWeakOverlap as
select P1.person as person
from   PersonWeakWithoutNewLine P1,
       PersonStrong P2
where  Overlaps(P1.person, P2.person);
--	and Not(ContainsRegex(/[\n\r]/, P2.person));

create view PersonWeakOnly as
	(select P.person as person from PersonWeakWithoutNewLine P)
	minus
	(select P.person as person from PersonWeakOverlap P);
  
/**
 * Union all the person names identified by the above rules
 */

create view PersonAll as
	(select P.person as person from PersonWeakOnly P)
union all
	(select P.person as person from PersonStrong P)	
    ;
/*union all
    (select P.firstname as person from FirstName P)
union all
    (select P.lastname as person from LastName P);
    */
/*
    (select P.person as person from Person1 P)
union all  
    (select P.person as person from Person1a P)
union all  
    (select P.person as person from Person3 P)
union all  
    (select P.person as person from Person3r1 P)
union all  
    (select P.person as person from Person3r2 P)
union all  
    (select P.person as person from Person4 P)
union all  
    (select P.person as person from Person4a P)
union all  
    (select P.person as person from Person2 P)
union all  
    (select P.person as person from Person2a P)
union all  
    (select P.person as person from Person4r1 P)
union all  
    (select P.person as person from Person4r2 P)
union all  
    (select P.person as person from Person5 P)
union all  
    (select P.person as person from Person6 P)
union all
    (select P.firstname as person from FirstName P)
union all
    (select P.lastname as person from LastName P);*/
 
 
/**
 * Keep only names in the same sentence
 */

create view PersonCorrect as
select PA.person as person
from PersonAll PA
where
--- start changing this block
--  Not(MatchesRegex(/(\p{Lu}\p{M}*)+[,\s]+\p{Lu}\p{M}*[\p{Ll}\p{Lo}]\p{M}*.*/, PA.person))
--  and Not(MatchesRegex(/\p{Lu}\p{M}*[\p{Ll}\p{Lo}]\p{M}*.*[,\s]+(\p{Lu}\p{M}*)+/, PA.person))
-- change is : account for 'all capitalized token' containing hyphens
  Not(MatchesRegex(/((\p{Lu}\p{M}*)|-)+[,\s]+\p{Lu}\p{M}*[\p{Ll}\p{Lo}]\p{M}*.*/, PA.person))
  and Not(MatchesRegex(/\p{Lu}\p{M}*[\p{Ll}\p{Lo}]\p{M}*.*[,\s]+((\p{Lu}\p{M}*)|-)+/, PA.person))
   and Not(MatchesRegex(/U\.\s*S\.\s*.+/, PA.person));
--- end changing this block

create view PersonSentence as
(select PA.person as person from PersonCorrect PA)
minus
(
	select PA.person as person
	from PersonCorrect PA, SentenceBoundary S
	where Contains(PA.person, S.boundary)
);  

---------------------------------------------
-- Consolidation:
-- For now, we just remove annotations that are completely
-- contained within other annotations.

   
  
  
create view OrgOverlapTime as
select O.org as org
from OrgSentence O, Times t
where Overlaps(t.match, O.org);

create view InvalidOrg as
	 
	select OP.org as org from OrgOverlapTime OP;

create view ValidOrg as 
	(select O.org as org from OrgSentence O)
	minus
	(select OP.org as org from InvalidOrg OP);
 
create view ValidOrgConsolidated as
select C.org as org
--from Consolidate(OrgSentence.org) C;
--from Consolidate(ValidOrg.org) C;
from ValidOrg C
consolidate on C.org;

create view FinalOrgExpanded as
select CombineSpans(CO.match, C.org) as org
from ValidOrgConsolidated C,
	 CapsOrg CO
where ContainsDict('OrgPartnershipDict', C.org)
 and FollowsTok(CO.match, C.org, 0, 2)
 and MatchesRegex(/\s*,?\s*&\s*/, SpanBetween(CO.match, C.org));

create view FinalOrgAll as
	(select O.org as org from ValidOrgConsolidated O)
	union all
	(select O.org as org from FinalOrgExpanded O);
	
create view FinalOrgConsolidated as
select C.org as org 
--from Consolidate(FinalOrgAll.org) C;
from FinalOrgAll C
consolidate on C.org;

-- Yunyao: change made on 03/24/2008 
--         avoid matches with . on both side
-- begain block change
create view FinalOrgConsolidatedWithDots as
select O.org as org
from FinalOrgConsolidated O
where MatchesRegex(/\./, LeftContextTok(O.org,1)) and
	  MatchesRegex(/\./, RightContextTok(O.org,1));
	
--select O.org as org into
--FinalOrgConsolidatedWithDotsOutput
--from FinalOrgConsolidatedWithDots O;

create view FinalOrgConsolidatedWithoutDots as
	(select O.org as org from FinalOrgConsolidated O)
	minus
	(select O.org as org from FinalOrgConsolidatedWithDots O);	
	
-- end block change

create view UrlEmailPlaceOrg as 
     (select R.org as match from FinalOrgConsolidatedWithoutDots R)
     union all
     (select R.match as match from USCity R);

create view PersonWithinUrlEmailPlaceOrg as
select PS.person as person
from PersonSentence PS, UrlEmailPlaceOrg R
where Contains (R.match, PS.person);

 
create view CitiesAll as 
	(select S.match as match from USCity S)
	union all
	(select S.match as match from GermanCities  S);
 
create view PersonOverlapsWithCities as
select P.person as person 
from PersonSentence P,
	 CitiesAll C
where Overlaps(C.match, P.person)
  and Not(Contains(P.person, C.match))
  and Not(Contains(C.match, P.person));
		  
create view InvalidPerson as
	(select P1.person as person from PersonWithinUrlEmailPlaceOrg P1)
	union all
	(select P1.person as person from PersonOverlapsWithCities P1);

create view ValidPerson as 
	(select P.person as person from PersonSentence P)
	minus
	(select P1.person as person from InvalidPerson P1);

create view FinalPersonConsolidated as
select C.person as person
--from Consolidate(PersonSentence.person) C;
--from Consolidate('LeftToRight', ValidPerson.person) C;
from ValidPerson C
consolidate on C.person
using 'LeftToRight';

create view UrlEmailPlaceOrgPerson as 
     (select R.match as match from UrlEmailPlaceOrg R)
     union all
     (select R.person as match from FinalPersonConsolidated R);
      
create view PersonStrongSingleTokenWithinUrlEmailPlaceOrg as
select PS.person as person
from PersonStrongSingleToken PS, UrlEmailPlaceOrgPerson R
where Contains (R.match, PS.person);
 
create view FinalPersonStrongSingleToken as 
	(select P.person as person from PersonStrongSingleToken P)
	minus
	(select P1.person as person from PersonStrongSingleTokenWithinUrlEmailPlaceOrg P1);
 
create view FinalPersonStrongSingleTokenConsolidated as
select C.person as person
--from Consolidate(FinalPersonStrongSingleToken.person) C;
from FinalPersonStrongSingleToken C
consolidate on C.person;


-- ===========================================================================
-- >>>>>>>>>>>>>>> Output section <<<<<<<<<<<<<<<<
-- ===========================================================================		

-- change output to remove unwanted types
-- select P.loc as loc
-- into Place
-- from Consolidate('OverlapOrdered',FinalPlaceConsolidated.loc) P;
 
	 
 
create view SystemTOrg as select O.org as org
--from Consolidate('OverlapOrdered',FinalOrgConsolidatedWithoutDots.org) O;
from FinalOrgConsolidatedWithoutDots O
consolidate on O.org
using 'OverlapOrdered';

output view SystemTOrg as 'com.ibm.systemT.Organization';

/*select P.person as person
into Person
--from Consolidate('OverlapOrdered', FinalPersonConsolidated.person) P;
from FinalPersonConsolidated P;

select P.person as person
into PersonSingleToken
from FinalPersonStrongSingleTokenConsolidated P; 
*/
 
--- start changing this block
/*create view PersonFinalAll as
(select P.person as person from FinalPersonConsolidated P)
union all
(select P.person as person from FinalPersonStrongSingleTokenConsolidated P);*/

-- filter entries where an invalid person fragment is present
-- filter entries where the token to the left is present in a dictionary
-- filter entries where the token to the right is present in a dictionary
-- filter entries where the token to the left matches a regular expression

create view PersonStrongSingleTokenOverlaps as
select P.person as person 
from FinalPersonStrongSingleTokenConsolidated P, FinalPersonConsolidated P1
where Overlaps(P.person,P1.person);

create view PersonStrongSingleTokenNonOverlaps as
(select P.person as person from FinalPersonStrongSingleTokenConsolidated P)
minus
(select P.person as person from  PersonStrongSingleTokenOverlaps P);

create view PersonFinalAllMatches as
(select P.person as person from FinalPersonConsolidated P)
union all
(select P.person as person from PersonStrongSingleTokenNonOverlaps P
 where Not(MatchesRegex(/.{1,2}/,P.person)));
 
-- Yunyao: added on 03/21/2008 to avoid matches overlapping with invalid person fragments
-- begin block change  
--create view PersonFinalAllCandidate as
--select P.person as person 
--from   PersonFinalAllMatches P
--where  Not(ContainsDict('dictionaries/InvalidPersonFragments.dict', P.person));

create view InvalidPersonFragments as
select D.match as match
from Dictionary('dictionaries/invalidPersonFragment.dict', Document.text) D;
 
create view InvalidPersonFinalAllMatches as
select P.person as person 
from   PersonFinalAllMatches P,
	   InvalidPersonFragments F
where Overlaps(F.match, P.person);

create view PersonFinalAllCandidate as
	(select P.person as person from PersonFinalAllMatches P)
	minus
	(select P.person as person from InvalidPersonFinalAllMatches P);
	
-- end block change
 
create view PersonContext as
select LeftContext(R.person,20) as lc, R.person as person, RightContext(R.person, 20) as rc
from   PersonFinalAllCandidate R;
 
create view PersonLeftContext as
select R.match as name 
from   Regex(/\b(\p{L}\p{M}*){1,20}\W+$/,  PersonContext.lc) R
where  ContainsDict('dictionaries/filterPerson_LCDict.dict', R.match);

create view PersonRightContext as
select R.match as name 
from   Regex(/\b(\p{L}\p{M}*){1,20}\W+$/,  PersonContext.rc) R
where  ContainsDict('dictionaries/filterPerson_RCDict.dict', R.match);

create view PersonFinalAllCandidateToDeleteLC as
select P.person as person
from PersonFinalAllCandidate P, PersonLeftContext PLC
where FollowsTok(PLC.name,P.person,0,1) and
      MatchesRegex(/\W+/,SpanBetween(PLC.name,P.person));

create view PersonFinalAllCandidateToDeleteLC1 as
select P.person as person
from PersonFinalAllCandidate P, PersonLeftContext PLC
where FollowsTok(PLC.name,P.person,0,1) and
	  MatchesRegex(/\W+/,SpanBetween(PLC.name,P.person)) and
      MatchesRegex(/.+(ing)/,PLC.name) and
      MatchesRegex(/.+,.+/,P.person);
      
create view PersonFinalAllCandidateToDeleteRC as
select P.person as person
from PersonFinalAllCandidate P, PersonRightContext PRC
where FollowsTok(P.person,PRC.name,0,1) and
      MatchesRegex(/\W+/,SpanBetween(P.person,PRC.name));

create view PersonFinalAllNoLC as
(select P.person as person from PersonFinalAllCandidate P)
minus
(select P.person as person from PersonFinalAllCandidateToDeleteLC P);

create view PersonFinalAllNoLC1 as
(select P.person as person from PersonFinalAllNoLC P)
minus
(select P.person as person from PersonFinalAllCandidateToDeleteLC1 P);

create view PersonFinalAll as
(select P.person as person from PersonFinalAllNoLC1 P)
minus
(select P.person as person from PersonFinalAllCandidateToDeleteRC P);

-- Yunyao: change made on 03/24/2008 
--         avoid matches with . on both side
-- begain block change
create view PersonFinalAllWithDots as
select P.person as person
from PersonFinalAll P
where MatchesRegex(/\./, LeftContextTok(P.person,1)) and
	  MatchesRegex(/\./, RightContextTok(P.person,1));
	  
create view PersonFinalAllWithoutDots as
	(select P.person as person from PersonFinalAll P)
	minus
	(select P.person as person from PersonFinalAllWithDots P);	

--select P.person as person into
--PersonFinalAllWithDotsOutput
--from PersonFinalAllWithDots P;

-- end block change
--- end changing this block
create view SystemTPerson as select P.person as person
--from Consolidate(PersonFinalAllWithoutDots.person) P;
from PersonFinalAllWithoutDots P
consolidate on P.person;

output view SystemTPerson as 'com.ibm.systemT.Person';

-- change output to remove types
--select S.match as loc
--into AllStates
--from StateStrongAll S;



-- change output to remove types	
--select C.match as loc
--into AllCities
--from Consolidate(CitiesAll.match) C;


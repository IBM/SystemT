/*******************************************************************************
 * Copyright IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 *******************************************************************************/

package com.ibm.avatar.algebra.function.base;

import java.util.ArrayList;
import java.util.Arrays;

import com.ibm.avatar.algebra.base.MemoizationTable;
import com.ibm.avatar.algebra.datamodel.AbstractTupleSchema;
import com.ibm.avatar.algebra.datamodel.FieldType;
import com.ibm.avatar.algebra.datamodel.TupleList;
import com.ibm.avatar.api.exceptions.FatalInternalError;
import com.ibm.avatar.api.exceptions.FunctionCallValidationException;
import com.ibm.avatar.api.exceptions.TextAnalyticsException;

/**
 * Special built-in "function" that acts as a placeholder for table locator arguments to AQL
 * functions.
 * <p>
 * Instances of this class are generated by the AOG parser when the parser encounters table locators
 * in the AOG.
 * 
 */
public class TableLocator extends TableReturningFunc {

  /** Dummy usage message to satisfy sanity checks in the parent class's constructor. */
  public static final String USAGE = "[internal function that implements table/view locators]";

  /** Name of the target view, table, etc. */
  private String targetName;

  /** Schema of the target. */
  private AbstractTupleSchema targetSchema;

  /** Index of the target in the inputs to the parent ApplyTableFunc operator. */
  private int targetIx;

  @Override
  public String toString() {
    return targetName;
  }

  /**
   * Constructor called from the AOG parser.
   * 
   * @param targetName name of the target view/table
   */
  public TableLocator(String targetName) {
    super(null, new ScalarFunc[0]);

    if (null == targetName) {
      throw new NullPointerException("Null target name ptr passed to TableLocator constructor.");
    }
    this.targetName = targetName;
  }

  /** @return name of the target view, table, etc. */
  public String getTargetName() {
    return targetName;
  }

  @Override
  public void bindImpl(AbstractTupleSchema[] targetSchemas, String[] targetNames) {
    if (null == targetNames) {
      throw new FatalInternalError("No targetNames ptr passed to TableLocator.bindImpl()");
    }

    // Find the target in the list of names
    targetIx = -1;
    for (int i = 0; i < targetNames.length; i++) {

      if (null == targetNames[i]) {
        throw new FatalInternalError(
            "Null pointer at index %d of targetNames array passed to TableLocator.bindImpl()", i);
      }

      if (targetName.equals(targetNames[i])) {
        targetIx = i;
      }
    }

    if (-1 == targetIx) {
      throw new FatalInternalError("Target view/table '%s' for locator argument not found.  "
          + "Available view names are: %s", targetName, Arrays.toString(targetNames));
    }

    if (null == targetSchemas[targetIx]) {
      throw new FatalInternalError(
          "Null schema pointer for view '%s', referenced via locator argument '%s'", targetName,
          this);
    }

    targetSchema = targetSchemas[targetIx];
  }

  @Override
  protected void validateArgTypes(ArrayList<FieldType> argTypes)
      throws FunctionCallValidationException {
    // Nothing to validate.
  }

  @Override
  public AbstractTupleSchema getOutputSchema() {
    if (null == targetSchema) {
      throw new FatalInternalError(
          "TableLocator.getOutputSchema() called before output schema initialized by bindImpl() method");
    }
    return targetSchema;
  }

  @Override
  public TupleList evaluate(TupleList[] childResults, MemoizationTable mt)
      throws TextAnalyticsException {
    // Children of an ApplyTableFunc operator are the targets of any record locator args
    return childResults[targetIx];
  }

}

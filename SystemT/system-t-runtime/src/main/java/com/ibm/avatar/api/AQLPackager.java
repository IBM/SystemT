/*******************************************************************************
 * Copyright IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 *******************************************************************************/
package com.ibm.avatar.api;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileFilter;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import com.ibm.avatar.algebra.util.dict.DictFile;
import com.ibm.avatar.algebra.util.file.RegexFileFilter;
import com.ibm.avatar.logging.Log;

/**
 * Utility class for packaging up a set of AQL files and dictionary files into a single large AQL
 * file. The class can also be invoked via its main() method.
 * 
 */
@Deprecated
public class AQLPackager {

  /** Encoding to use when creating output files. */
  // public static String ENCODING_NAME = "UTF-16";
  /**
   * Main method for invoking this class from a script.
   * 
   * @param args first argument is dictionaries dir, second is dictionary prefix, and remaining are
   *        AQL file names; last file name (AQL or AOG) is the output
   */
  public static int main(String[] args) throws Exception {
    String USAGE = "Usage: java AQLPackager input_encoding output_encoding "
        + "dicts_dir dict_prefix aqlfile output";

    // Number of arguments, not including AQL files and output
    if (args.length != 6) {
      System.err.print(USAGE + "\n");
      throw new Exception(USAGE);
    }

    // Unpack fixed-position arguments
    String inputEncodingName = args[0];
    String outputEncodingName = args[1];
    String dictsDirName = args[2];
    String dictPrefix = args[3];
    String aqlFileName = args[4];
    String outputFileName = args[5];

    // Get a list of dictionary files.
    // File[] dictFiles = AQLPackager.dictFilesInDir(new
    // File(dictsDirName));

    AQLPackager p = new AQLPackager(new File(aqlFileName), new File(dictsDirName), dictPrefix,
        inputEncodingName);

    OutputStreamWriter out =
        new OutputStreamWriter(new FileOutputStream(outputFileName), outputEncodingName);

    out.write(p.getAql());
    out.close();

    System.err.print("Done.\n");
    return 0;
  }

  /*
   * CONSTANTS
   */

  /**
   * Regular expression for the name of an AQL file
   */
  public static final String AQL_FILE_NAME_REGEX = "\\A.*\\.aql\\Z";

  /**
   * Regular expression for the name of a dictionary file.
   */
  public static final String DICT_FILE_NAME_REGEX = "\\A.*\\.(dict|txt)\\Z";

  /**
   * Regular expression for an "include" line statement (assumed to be one line!)
   */
  public static final Pattern INCLUDE_REGEX = Pattern.compile("\\s*include\\s+'([^']*)';\\s*");

  /** Header that goes at the top of the generated AQL. */
  private static final String GLOBAL_HDR =

      "----------------------------------------------------------------------\n"
          + "-- This AQL file was GENERATED by AQLPackager\n" + "--\n" + "-- DO NOT EDIT\n"
          + "----------------------------------------------------------------------\n";

  /**
   * Header that goes before each input AQL file in the output. Actually a template for
   * String.format().
   */
  private static final String AQL_FILE_HDR = "\n---------- BEGIN %20s ------------------------\n";

  /**
   * Header that goes *after* each input AQL file in the output. Actually a template for
   * String.format().
   */
  private static final String AQL_FILE_FOOTER =
      "\n---------- END %20s   ------------------------\n";

  /*
   * FIELDS
   */

  /** AQL file to inline. */
  private File aqlFile;
  // private File[] aqlfiles;

  /** Directory containing original dictionary files. */
  private File dictDir;

  /** Dictionary files to inline */
  // private File[] dictfiles;
  /** String to prepend to the internal names of inlined dictionaries */
  private String dictNamePrefix;

  /** Encoding in which to read the input file. */
  private String inputEncodingName;

  /** The merged aql string. */
  private String aql;

  // public AQLPackager(File[] aqlfiles, File[] dictfiles,
  // String dictFilesRoot,
  // String dictNamePrefix, String inputEncodingName) throws Exception {
  // this.aqlfiles = aqlfiles;
  // this.dictfiles = dictfiles;
  // this.dictNamePrefix = dictNamePrefix;
  // this.inputEncodingName = inputEncodingName;
  //
  // packageAQL();
  // }

  /**
   * Main constructor
   * 
   * @param aqlFile top-level AQL file.
   * @param dictDir directory containing dictionary files
   * @param dictNamePrefix String to prepend to the internal names of inlined dictionaries
   * @param inputEncodingName encoding to use when reading input AQL and dictionary files
   */
  public AQLPackager(File aqlFile, File dictDir, String dictNamePrefix, String inputEncodingName)
      throws Exception {
    this.aqlFile = aqlFile;
    this.dictDir = dictDir;
    // dictfiles = dictFilesInDir(dictDir);

    this.dictNamePrefix = dictNamePrefix;
    this.inputEncodingName = inputEncodingName;

    packageAQL();
  }

  /**
   * Get a list of the dictionary files in a given directory; uses file names to filter out
   * non-dictionary files.
   * 
   * @param dir parent directory
   * @return array of files, one per dictionary
   */
  public static File[] dictFilesInDir(File dir) {
    ArrayList<File> files = getAllFiles(dir, new RegexFileFilter(DICT_FILE_NAME_REGEX));
    return files.toArray(new File[files.size()]);
  }

  /**
   * Recursive method to find all the files in a directory subtree that match a filter.
   */
  private static ArrayList<File> getAllFiles(File root, FileFilter filter) {
    ArrayList<File> ret = new ArrayList<File>();
    File[] rootFiles = root.listFiles(filter);
    if (null != rootFiles) {
      for (File file : rootFiles) {
        ret.add(file);
      }
    }

    // Recurse on subdirectories.
    File[] allRootFiles = root.listFiles();
    if (null != allRootFiles) {
      for (File child : allRootFiles) {
        if (child.isDirectory()) {
          ret.addAll(getAllFiles(child, filter));
        }
      }
    }

    return ret;
  }

  public static File[] aqlFilesInDir(File dir) {
    return dir.listFiles(new RegexFileFilter(AQL_FILE_NAME_REGEX));
  }

  /**
   * Merge all inputs into a single AQL string.
   */
  private void packageAQL() throws Exception {
    StringBuilder sb = new StringBuilder();

    // Start with the global header.
    sb.append(GLOBAL_HDR);

    // Then append the individual AQL files.
    sb.append(packageAQLFile(aqlFile));

    // Then convert and append the dictionary files.
    inlineDictFiles(sb);

    aql = sb.toString();
  }

  /** Recursive function to package a single AQL file. */
  private String packageAQLFile(File aqlfile) throws IOException {
    StringBuilder sb = new StringBuilder();

    // Make sure the directory separators are forward slashes, to avoid
    // screwing up regression tests.
    String aqlfileName = unixPath(aqlfile);

    System.err.printf("Processing AQL file %s\n", aqlfileName);
    sb.append(String.format(AQL_FILE_HDR, aqlfileName));

    BufferedReader in =
        new BufferedReader(new InputStreamReader(new FileInputStream(aqlfile), inputEncodingName));

    String line;
    while (null != (line = in.readLine())) {
      Matcher m = INCLUDE_REGEX.matcher(line);

      if (line.contains("include")) {
        System.err.printf("Potential include: '%s'\n", line);
      }

      if (m.matches()) {

        String includedFileName = m.group(1);

        System.err.printf("    Including '%s'\n", includedFileName);

        // Assume for now that the include file is in the same
        // directory.
        File includedFile = new File(aqlfile.getParent(), includedFileName);

        // Recurse!
        sb.append(packageAQLFile(includedFile));

      } else {
        sb.append(line);
        sb.append('\n');
      }
    }

    in.close();

    sb.append(String.format(AQL_FILE_FOOTER, aqlfileName));
    return sb.toString();
  }

  private void inlineDictFiles(StringBuilder sb) throws Exception {

    File[] dictfiles = dictFilesInDir(dictDir);
    for (int i = 0; i < dictfiles.length; i++) {
      File dictfile = dictfiles[i];

      try {

        String dictfilePath = unixPath(dictfile);

        System.err.printf("Inlining dictionary file %s\n", dictfilePath);
        sb.append(String.format(AQL_FILE_HDR, dictfilePath));

        // Load the lines into a DictFile object. Doing so has two
        // purposes:
        // 1. Buffers up the entries so that we can avoid putting a
        // comma
        // after the last one in the inline dictionary.
        // 2. Removes comments, escapes, and empty lines.
        DictFile dict = new DictFile(dictfile);

        List<String> entries = dict.getEntries();

        // Generate a dictionary name that will be the same as the one
        // used
        // in the AQL references to our dictionary file.
        String dictname = computeDictName(dictfile);

        System.err.printf("  ==> Internal name is %s\n", dictname);

        // Name of inline dictionary is same as dictionary file.
        sb.append(String.format("create dictionary \"%s\" as (\n", dictname));

        for (int lineno = 0; lineno < entries.size(); lineno++) {
          String entry = entries.get(lineno);

          // Escape backslashes (MUST COME FIRST!)
          entry = entry.replace("\\", "\\\\");

          // Escape any single quotes in the entry.
          entry = entry.replace("'", "\\'");

          if (lineno < entries.size() - 1) {
            sb.append(String.format("    '%s',\n", entry));
          } else {
            // No comma on last entry.
            sb.append(String.format("    '%s'\n", entry));
          }
        }
        sb.append(");\n\n");

        sb.append(String.format(AQL_FILE_FOOTER, dictfilePath));

      } catch (Throwable t) {
        Log.debug("Caught exception (%s) " + "while processing dict file '%s'", t, dictfile);
        throw new Exception(t);
      }
    }
  }

  /**
   * Compute the internal dictionary name to use for the inline dictionary that corresponds to the
   * indicated file.
   */
  private String computeDictName(File dictfile) throws IOException {
    // Strip off the dict files dir from the beginning of the dict file's
    // path. We do this using canonical filenames.
    String dictFilesDirCanon = dictDir.getCanonicalPath();
    String dictfileCanon = dictfile.getCanonicalPath();

    String dictfileStripped = dictfileCanon.substring(dictFilesDirCanon.length());

    if (null == dictNamePrefix || "".equals(dictNamePrefix)) {
      // No dictionary name prefix; strip off any leading slashes.
      if (File.separatorChar == (dictfileStripped.charAt(0))) {
        dictfileStripped = dictfileStripped.substring(1);
      }
    }

    // Now convert backslashes to forward slashes so that the inlined
    // dictionaries will be named with UNIX-style paths.
    dictfileStripped = dictfileStripped.replace('\\', '/');

    return dictNamePrefix + dictfileStripped;
  }

  /** Convert to a UNIX-style path, with forward slashes between dirs. */
  private String unixPath(File f) {
    String pathStr = f.getPath();

    pathStr = pathStr.replace(File.separatorChar, '/');

    return pathStr;
  }

  public String getAql() {
    return aql;
  }

}

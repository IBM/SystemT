/*******************************************************************************
 * Copyright IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 *******************************************************************************/
//
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
// Implementation, vJAXB 2.1.10 in
// JDK 6
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
// Any modifications to this file will be lost upon recompilation of the source schema.
// Generated on: 2012.06.19 at 04:26:09 PM IST
//

package com.ibm.avatar.aql.tam;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlType;

import com.ibm.avatar.algebra.util.dict.DictParams.CaseSensitivityType;
import com.ibm.avatar.api.exceptions.FatalInternalError;
import com.ibm.avatar.api.tam.DictionaryMetadata;
import com.ibm.avatar.aql.doc.AQLDocComment;
import com.ibm.biginsights.textanalytics.util.ObjectComparator;

/**
 * JAXB class to represent metadata of Dictionary objects.
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "DictionaryMetadataImpl", namespace = "http://www.ibm.com/aql",
    propOrder = {"comment"})
public class DictionaryMetadataImpl implements DictionaryMetadata {

  private static final long serialVersionUID = -7494224628731753632L;

  /**
   * The comment for this construct, with leading and trainling comment separators removed, and
   * leading asterisks on each line also removed.
   */
  @XmlElement
  protected CommentType comment;
  @XmlAttribute
  protected String dictName;
  @XmlAttribute
  protected Boolean exported;
  @XmlAttribute
  protected Boolean external;
  @XmlAttribute(name = "case")
  protected String _case;
  @XmlAttribute
  protected String languages;

  @XmlAttribute
  protected Boolean allowEmpty;
  @XmlAttribute
  protected Boolean required;
  @XmlAttribute
  protected boolean supportLemmaMatch;
  @XmlAttribute
  protected boolean srcExtTable;
  @XmlAttribute
  protected String extTableName;
  @XmlAttribute
  protected String extTableColName;

  /**
   * Gets the value of the dictName property.
   * 
   * @return possible object is {@link String }
   */
  @Override
  public String getDictName() {
    return dictName;
  }

  /**
   * Sets the value of the dictName property.
   * 
   * @param value allowed object is {@link String }
   */
  public void setDictName(String value) {
    this.dictName = value;
  }

  /**
   * Gets the value of the comment property.
   * 
   * @return the comment
   */
  @Override
  public String getComment() {
    if (null == comment)
      return null;
    return comment.getText();
  }

  /**
   * Sets the value of the comment property.
   * 
   * @param value allowed object is {@link CommentType }
   */
  public void setComment(CommentType value) {
    this.comment = value;
  }

  /**
   * Gets the value of the exported property.
   * 
   * @return possible object is {@link Boolean }
   */
  public Boolean getExported() {
    return exported;
  }

  /**
   * Sets the value of the exported property.
   * 
   * @param value allowed object is {@link Boolean }
   */
  public void setExported(Boolean value) {
    this.exported = value;
  }

  /**
   * Gets the value of the external property.
   * 
   * @return possible object is {@link Boolean }
   */
  public Boolean getExternal() {
    return external;
  }

  /**
   * Sets the value of the external property.
   * 
   * @param value allowed object is {@link Boolean }
   */
  public void setExternal(Boolean value) {
    this.external = value;
  }

  /**
   * Gets the value of the case property.
   * 
   * @return possible object is {@link String }
   */
  public String getCase() {
    return _case;
  }

  /**
   * Sets the value of the case property.
   * 
   * @param value allowed object is {@link String }
   */
  public void setCase(String value) {
    this._case = value;
  }

  /**
   * Gets the value of the languages property.
   * 
   * @return possible object is {@link String }
   */
  @Override
  public String getLanguages() {
    return languages;
  }

  /**
   * Sets the value of the languages property.
   * 
   * @param value allowed object is {@link String }
   */
  public void setLanguages(String value) {
    this.languages = value;
  }

  @Override
  public CaseSensitivityType getCaseType() {
    String caseVal = getCase();
    if ("insensitive".equals(caseVal)) {
      return CaseSensitivityType.insensitive;
    } else if ("folding".equals(caseVal)) {
      return CaseSensitivityType.folding;
    } else {
      return CaseSensitivityType.exact;
    }
  }

  @Override
  public boolean isExternal() {
    return getExternal().booleanValue();
  }

  @Override
  public boolean isExported() {
    return getExported().booleanValue();
  }

  @Override
  public boolean isLemmaMatch() {
    return this.supportLemmaMatch;
  }

  /**
   * Returns the name of the external table that the dictionary depends on. If the dictionary does
   * not depend upon an external table, this value is <code>null</code>.
   * 
   * @return name of the external table
   * @exception UnsupportedOperationException if invoked on internal dictionary metadata instance
   */
  public String getExtTableName() {
    if (true == isExternal())
      throw new UnsupportedOperationException(
          "This method should never be called for external dictionaries");

    return extTableName;
  }

  /**
   * Returns the column name of the external table that is the source of dictionary entries. If the
   * dictionary does not depend upon an external table, this value is <code>null</code>.
   * 
   * @return column name of the external table which is the source of dictionary entries
   * @exception UnsupportedOperationException if invoked on internal dictionary metadata instance
   */
  public String getExtTableColName() {
    if (true == isExternal())
      throw new UnsupportedOperationException(
          "This method should never be called for external dictionaries");

    return extTableColName;
  }

  /**
   * Specifies whether the dictionary uses an external table as its source. This occurs when a table
   * is created using the <code>create external table</code> statement, and then the dictionary is
   * created from this table using the <code>create dictionary from table</code> statement.
   * 
   * @return <code>true</code>, if an external table acts as the source of the dictionary entries
   * @exception UnsupportedOperationException if invoked on internal dictionary metadata instance
   */
  public boolean isSrcExtTable() {
    if (true == isExternal())
      throw new UnsupportedOperationException(
          "This method should never be called for external dictionaries");
    return srcExtTable;
  }

  @Override
  public Boolean isAllowEmpty() {
    if (false == isExternal())
      throw new UnsupportedOperationException(
          "This method should never be called for internal dictionaries");
    return allowEmpty;
  }

  /**
   * @param allowEmpty the value to set the allow_empty flag to
   */
  public void setAllowEmpty(boolean allowEmpty) {
    this.allowEmpty = allowEmpty;
  }

  @Override
  public Boolean isRequired() {
    if (false == isExternal())
      throw new UnsupportedOperationException(
          "This method should never be called for internal dictionaries");
    return required;
  }

  /**
   * @param required the value to set the required flag to
   */
  public void setRequired(boolean required) {
    this.required = required;
  }


  /**
   * 
   * @param lemmaMatch true if the dictionary has the lemma_match flag, false otherwise
   */
  public void setLemmaMatch(boolean lemmaMatch) {
    this.supportLemmaMatch = lemmaMatch;
  }

  /**
   * @param srcExtTable the srcExtTable to set
   */
  public void setSrcExtTable(boolean srcExtTable) {
    this.srcExtTable = srcExtTable;
  }

  /**
   * @param extTableName the extTableName to set
   */
  public void setExtTableName(String extTableName) {
    this.extTableName = extTableName;
  }

  /**
   * @param extTableColName the extTableColName to set
   */
  public void setExtTableColName(String extTableColName) {
    this.extTableColName = extTableColName;
  }

  /**
   * Set the AQL doc comment string associated with this dictionary. If the input comment exists,
   * that is, the AQL file where this statement was defined did contain an AQL doc comment for this
   * statement, we set the comment to be a lightly cleaned up version of the original comment text,
   * as provided by {@link AQLDocComment#getCleanedText()}.
   * 
   * @param comment AQL doc comment associated with this statement in the AQL code
   */
  public void setComment(AQLDocComment comment) {
    if (null != comment) {
      this.comment = new CommentType();
      this.comment.setText(comment.getCleanText());
    }
  }

  @Override
  public boolean equals(Object obj) {
    if (obj == null) {
      return false;
    }
    if (false == obj instanceof DictionaryMetadataImpl)
      return false;

    DictionaryMetadataImpl other = (DictionaryMetadataImpl) obj;

    // use null for <code>moduleName</code> in calls to ModuleMetadataMismatchException()
    // constructor below, as we do
    // not know the module name at this point. ModuleMetadataImpl.equals() would set the
    // <code>moduleName</code> before
    // re-throwing this exception to the consumers.

    // case
    if (false == ObjectComparator.equals(_case, other._case))
      throw new ModuleMetadataMismatchException(null, "dictionary.case", this._case, other._case);

    // comment
    if (false == ObjectComparator.equals(this.getComment(), other.getComment()))
      throw new ModuleMetadataMismatchException(null, "dictionary.comment", this.getComment(),
          other.getComment());

    // dictName
    if (false == ObjectComparator.equals(this.dictName, other.dictName))
      throw new ModuleMetadataMismatchException(null, "dictionary.dictName", this.dictName,
          other.dictName);

    // exported
    if (false == ObjectComparator.equals(this.exported, other.exported))
      throw new ModuleMetadataMismatchException(null, "dictionary.exported",
          this.exported.toString(), other.exported.toString());

    // external
    if (false == ObjectComparator.equals(this.external, other.external))
      throw new ModuleMetadataMismatchException(null, "dictionary.external",
          this.external.toString(), other.external.toString());

    // extTableColName
    if (false == ObjectComparator.equals(this.extTableColName, other.extTableColName))
      throw new ModuleMetadataMismatchException(null, "dictionary.extTableColName",
          this.extTableColName, other.extTableColName);

    // extTableName
    if (false == ObjectComparator.equals(this.extTableName, other.extTableName))
      throw new ModuleMetadataMismatchException(null, "dictionary.extTableName", this.extTableName,
          other.extTableName);

    // languages
    if (false == ObjectComparator.equals(this.languages, other.languages))
      throw new ModuleMetadataMismatchException(null, "dictionary.languages", this.languages,
          other.languages);

    // allow empty
    if (this.allowEmpty != other.allowEmpty)
      throw new ModuleMetadataMismatchException(null, "dictionary.allowEmpty",
          String.valueOf(this.allowEmpty), String.valueOf(other.allowEmpty));

    // isExported
    if (false == ObjectComparator.equals(this.exported, other.exported))
      throw new ModuleMetadataMismatchException(null, "dictionary.isExported",
          String.valueOf(this.exported), String.valueOf(other.exported));

    // isExternal
    if (false == ObjectComparator.equals(this.external, other.external))
      throw new ModuleMetadataMismatchException(null, "dictionary.external",
          String.valueOf(this.external), String.valueOf(other.external));

    // isSrcExtTable
    if (false == ObjectComparator.equals(this.srcExtTable, other.srcExtTable))
      throw new ModuleMetadataMismatchException(null, "dictionary.srcExtTable",
          String.valueOf(this.srcExtTable), String.valueOf(other.srcExtTable));

    // return true, if all checks pass
    return true;
  }

  @Override
  public int hashCode() {
    throw new FatalInternalError("Hashcode not implemented for class %s.",
        this.getClass().getSimpleName());
  }

  @Override
  public String toString() {
    return String.format(
        "dictName: %s, exported: %s, _case: %s, lemmaMatch: %s, languages: %s, allowEmpty: %s, srcExtTable: %s, srcExtTable: %s, extTableName: %s, extTableColName: %s",
        dictName, exported, _case, supportLemmaMatch, languages, allowEmpty, srcExtTable,
        srcExtTable, extTableName, extTableColName);
  }
}

/*******************************************************************************
 * Copyright IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 *******************************************************************************/
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
// Implementation, vJAXB 2.1.10 in
// JDK 6
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
// Any modifications to this file will be lost upon recompilation of the source schema.
// Generated on: 2012.06.19 at 04:26:09 PM IST
//

package com.ibm.avatar.aql.tam;

import java.util.List;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlType;

import com.ibm.avatar.api.exceptions.FatalInternalError;
import com.ibm.avatar.api.tam.FunctionMetadata;
import com.ibm.avatar.api.tam.Param;
import com.ibm.avatar.aql.FuncLanguage;
import com.ibm.avatar.aql.doc.AQLDocComment;
import com.ibm.biginsights.textanalytics.util.ObjectComparator;

/**
 * JAXB class to represent metadata of a UDF function.
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "FunctionMetadataImpl", namespace = "http://www.ibm.com/aql",
    propOrder = {"input", "comment"})
public class FunctionMetadataImpl implements FunctionMetadata {

  private static final long serialVersionUID = -6763343806104384889L;
  protected InputType input;
  /**
   * The comment for this construct, with leading and trainling comment separators removed, and
   * leading asterisks on each line also removed.
   */
  @XmlElement
  protected CommentType comment;
  @XmlAttribute
  protected Boolean exported;
  @XmlAttribute
  protected String returnType;

  // Language is represented by an enum, but we keep it as a String here for consistency with the
  // XML
  @XmlAttribute
  protected String language;
  @XmlAttribute
  protected Boolean deterministic;
  @XmlAttribute
  protected Boolean returnsNullOnNullInput;
  @XmlAttribute
  protected String functionName;
  @XmlAttribute
  protected String externalName;

  @XmlAttribute
  protected String returnLikeParam;

  /**
   * Gets the value of the input property.
   * 
   * @return possible object is {@link InputType }
   */
  public InputType getInput() {
    return input;
  }

  /**
   * Sets the value of the input property.
   * 
   * @param value allowed object is {@link InputType }
   */
  public void setInput(InputType value) {
    this.input = value;
  }

  /**
   * Gets the value of the exported property.
   * 
   * @return possible object is {@link Boolean }
   */
  public Boolean getExported() {
    return exported;
  }

  /**
   * Sets the value of the exported property.
   * 
   * @param value allowed object is {@link Boolean }
   */
  public void setExported(Boolean value) {
    this.exported = value;
  }

  /**
   * Gets the value of the returnType property.
   * 
   * @return possible object is {@link String }
   */
  @Override
  public String getReturnType() {
    return returnType;
  }

  /**
   * Sets the value of the returnType property.
   * 
   * @param value allowed object is {@link String }
   */
  public void setReturnType(String value) {
    this.returnType = value;
  }

  /** See superclass for detailed JavaDoc */
  @Override
  public String getReturnLikeParam() {
    return returnLikeParam;
  }

  /**
   * Setter that corresponds to {@link #getReturnLikeParam()}
   * 
   * @param val new value for the "return ... like ..." property
   */
  public void setReturnLikeParam(String val) {
    this.returnLikeParam = val;
  }

  /**
   * Gets the value of the language property.
   * 
   * @return implementation language of the function, translated from the string representation in
   *         the XML
   */
  @Override
  public FuncLanguage getLanguage() {
    return FuncLanguage.valueOf(language);
  }

  /**
   * Sets the value of the language property.
   * 
   * @param value internal representation of the language (XML stores it as a string)
   */
  public void setLanguage(FuncLanguage value) {
    this.language = value.toString();
  }

  /**
   * Gets the value of the deterministic property.
   * 
   * @return possible object is {@link Boolean }
   */
  public Boolean getDeterministic() {
    return deterministic;
  }

  /**
   * Sets the value of the deterministic property.
   * 
   * @param value allowed object is {@link Boolean }
   */
  public void setDeterministic(Boolean value) {
    this.deterministic = value;
  }

  /**
   * Gets the value of the returnsNullOnNullInput property.
   * 
   * @return possible object is {@link Boolean }
   */
  public Boolean getReturnsNullOnNullInput() {
    return returnsNullOnNullInput;
  }

  /**
   * Sets the value of the returnsNullOnNullInput property.
   * 
   * @param value allowed object is {@link Boolean }
   */
  public void setReturnsNullOnNullInput(Boolean value) {
    this.returnsNullOnNullInput = value;
  }

  /**
   * Gets the value of the functionName property.
   * 
   * @return possible object is {@link String }
   */
  @Override
  public String getFunctionName() {
    return functionName;
  }

  /**
   * Sets the value of the functionName property.
   * 
   * @param value allowed object is {@link String }
   */
  public void setFunctionName(String value) {
    this.functionName = value;
  }

  /**
   * Gets the value of the externalName property.
   * 
   * @return possible object is {@link String }
   */
  @Override
  public String getExternalName() {
    return externalName;
  }

  /**
   * Sets the value of the externalName property.
   * 
   * @param value allowed object is {@link String }
   */
  public void setExternalName(String value) {
    this.externalName = value;
  }

  @Override
  public Param[] getParameters() {
    List<InputType.Param> params = getInput().getParam();
    Param[] ret = new Param[params.size()];
    for (int i = 0; i < params.size(); ++i) {
      InputType.Param p = params.get(i);
      ret[i] = new Param(p.name, p.type);
    }
    return ret;
  }

  @Override
  public boolean isDeterministic() {
    return getDeterministic().booleanValue();
  }

  @Override
  public boolean returnsNullOnNullInput() {
    return getReturnsNullOnNullInput().booleanValue();
  }

  @Override
  public boolean isExported() {
    return getExported().booleanValue();
  }

  /**
   * Set the AQL doc comment string associated with this function. If the input comment exists, that
   * is, the AQL file where this statement was defined did contain an AQL doc comment for this
   * statement, we set the comment to be a lightly cleaned up version of the original comment text,
   * as provided by {@link AQLDocComment#getCleanedText()}.
   * 
   * @param comment AQL doc comment associated with this statement in the AQL code
   */
  public void setComment(AQLDocComment comment) {
    if (null != comment) {
      this.comment = new CommentType();
      this.comment.setText(comment.getCleanText());
    }
  }

  /**
   * Gets the value of the comment property.
   * 
   * @return the comment
   */
  @Override
  public String getComment() {
    if (null == comment)
      return null;
    return comment.getText();
  }

  /**
   * Sets the value of the comment property.
   * 
   * @param value allowed object is {@link CommentType }
   */
  public void setComment(CommentType value) {
    this.comment = value;
  }

  @Override
  public boolean equals(Object obj) {

    if (obj == null) {
      return false;
    }
    if (false == obj instanceof FunctionMetadataImpl)
      return false;

    FunctionMetadataImpl other = (FunctionMetadataImpl) obj;

    // use null for <code>moduleName</code> in calls to ModuleMetadataMismatchException()
    // constructor below, as we do
    // not know the module name at this point. ModuleMetadataImpl.equals() would set the
    // <code>moduleName</code> before
    // re-throwing this exception to the consumers.

    // comment
    if (false == ObjectComparator.equals(this.getComment(), other.getComment()))
      throw new ModuleMetadataMismatchException(null, "function.comment", this.getComment(),
          other.getComment());

    // deterministic
    if (false == ObjectComparator.equals(this.deterministic, other.deterministic))
      throw new ModuleMetadataMismatchException(null, "function.deterministic",
          String.valueOf(this.deterministic), String.valueOf(other.deterministic));

    // exported
    if (false == ObjectComparator.equals(this.exported, other.exported))
      throw new ModuleMetadataMismatchException(null, "function.exported",
          String.valueOf(this.exported), String.valueOf(other.exported));

    // externalName
    if (false == ObjectComparator.equals(this.externalName, other.externalName))
      throw new ModuleMetadataMismatchException(null, "function.externalName",
          String.valueOf(this.externalName), String.valueOf(other.externalName));

    // functionName
    if (false == ObjectComparator.equals(this.functionName, other.functionName))
      throw new ModuleMetadataMismatchException(null, "function.functionName",
          String.valueOf(this.functionName), String.valueOf(other.functionName));

    // input
    if (false == ObjectComparator.equals(this.input, other.input))
      throw new ModuleMetadataMismatchException(null, "function.input", String.valueOf(this.input),
          String.valueOf(other.input));

    // language
    if (false == ObjectComparator.equals(this.language, other.language))
      throw new ModuleMetadataMismatchException(null, "function.language",
          String.valueOf(this.language), String.valueOf(other.language));

    // returnsNullOnNullInput
    if (false == ObjectComparator.equals(this.returnsNullOnNullInput, other.returnsNullOnNullInput))
      throw new ModuleMetadataMismatchException(null, "function.returnsNullOnNullInput",
          String.valueOf(this.returnsNullOnNullInput),
          String.valueOf(other.returnsNullOnNullInput));

    // returnType
    if (false == ObjectComparator.equals(this.returnType, other.returnType)) {
      // Special case: String and Text are equal
      String thisType = this.returnType;
      if ("String".equals(thisType))
        thisType = "Text";
      String otherType = other.returnType;
      if ("String".equals(otherType))
        otherType = "Text";
      if (!thisType.equals(otherType))
        throw new ModuleMetadataMismatchException(null, "function.returnType", thisType, otherType);
    }


    // return true, if all tests pass
    return true;
  }

  @Override
  public int hashCode() {
    throw new FatalInternalError("Hashcode not implemented for class %s.",
        this.getClass().getSimpleName());
  }

  @Override
  public String toString() {
    return String.format(
        "functionName: %s, externalName: %s, returnType: %s, returnLikeParam: %s, exported: %s, language: %s, deterministic: %s, returnsNullOnNullInput: %s",
        functionName, externalName, returnType, returnLikeParam, exported, language, deterministic,
        returnsNullOnNullInput);
  }

}

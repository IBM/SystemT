/*******************************************************************************
 * Copyright IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 *******************************************************************************/
/* Generated By:JavaCC: Do not edit this line. ParseException.java Version 5.0 */
/* JavaCCOptions:KEEP_LINE_COL=null */
package com.ibm.avatar.aql;

import java.util.HashMap;
import java.util.Map;

/**
 * This exception is thrown when parse errors are encountered. You can explicitly create objects of
 * this exception type by calling the method generateParseException in the generated parser. You can
 * modify this class to customize your error reporting mechanisms so long as you retain the public
 * fields.
 */
@SuppressWarnings("all")
public class ParseException extends Exception {

  /**
   * The version identifier for this Serializable class. Increment only if the <i>serialized</i>
   * form of the class changes.
   */
  private static final long serialVersionUID = 1L;

  /**
   * Map of AQL token id (with not so user friendly textual representation) vs their more user
   * friendly equivalent textual representation.
   */
  private static final Map<Integer, String> userFriendlyTokenMap;

  /**
   * Initialize the map declared above
   */
  static {
    userFriendlyTokenMap = new HashMap<Integer, String>();

    userFriendlyTokenMap.put(AQLParserConstants.NICKNAME, "\"Simple identifier\"");
    userFriendlyTokenMap.put(AQLParserConstants.SQL_STRING_LITERAL, "\"String constant\"");
    userFriendlyTokenMap.put(AQLParserConstants.DBLQUOTE_STRING_LITERAL,
        "\"Double-quoted identifier\"");
    userFriendlyTokenMap.put(AQLParserConstants.REGEX_LITERAL, "\"Regular expression\"");
  }

  /**
   * Flag to determine if the ParseException was constructed with token information
   */
  protected boolean isConstructedWithTokenInfo = false;

  /**
   * This constructor is used by the method "generateParseException" in the generated parser.
   * Calling this constructor generates a new object of this type with the fields "currentToken",
   * "expectedTokenSequences", and "tokenImage" set.
   */
  public ParseException(Token currentTokenVal, int[][] expectedTokenSequencesVal,
      String[] tokenImageVal) {
    super();
    isConstructedWithTokenInfo = true;
    currentToken = currentTokenVal;
    expectedTokenSequences = expectedTokenSequencesVal;
    tokenImage = tokenImageVal;
    errorDescription =
        prepareErrorDescription(currentTokenVal, expectedTokenSequencesVal, tokenImageVal);
    erroneousLineNumber = currentToken.next.beginLine;
    erroneousColumnNumber = currentToken.next.beginColumn;
  }

  /**
   * The following constructors are for use by you for whatever purpose you can think of.
   * Constructing the exception in this manner makes the exception behave in the normal way - i.e.,
   * as documented in the class "Throwable". The fields "errorToken", "expectedTokenSequences", and
   * "tokenImage" do not contain relevant information. The JavaCC generated code does not use these
   * constructors.
   */

  public ParseException() {
    super();
  }

  /** Constructor with message. */
  public ParseException(String message) {
    this(null, message);
  }

  /** Constructor with message and root cause. */
  public ParseException(Throwable cause, String message) {
    super(message, cause);

    errorDescription = message;
  }

  /**
   * This is the last token that has been consumed successfully. If this object has been created due
   * to a parse error, the token following this token will (therefore) be the first error token.
   */
  public Token currentToken;

  /**
   * Each entry in this array is an array of integers. Each array of integers represents a sequence
   * of tokens (by their ordinal values) that is expected at this point of the parse.
   */
  public int[][] expectedTokenSequences;

  /**
   * This is a reference to the "tokenImage" array of the generated parser within which the parse
   * error occurred. This array is defined in the generated ...Constants interface.
   */
  public String[] tokenImage;

  /** Error description without error location details */
  protected String errorDescription;

  /** Erroneous line number */
  protected int erroneousLineNumber;

  /** Erroneous column number */
  protected int erroneousColumnNumber;

  /**
   * Number of lines that we should adjust the line number with. Use negative numbers to subtract
   * lines. This is used by backward compatibility API.
   */
  protected int lineAdjustment = 0;

  /**
   * It uses "currentToken" and "expectedTokenSequences" to generate a parse error message and
   * returns it. If this object has been created due to a parse error, and you do not catch it (it
   * gets thrown from the parser) the correct error message gets displayed.
   */
  @Override
  public String getMessage() {
    // Just return the original message if there is no Token Information
    if (false == isConstructedWithTokenInfo) {
      return super.getMessage();
    } else {
      // prepare a message with token information
      String errorLine = "At line " + getLine() + ", column " + getColumn() + " ";
      return errorLine + prepareErrorDescription(currentToken, expectedTokenSequences, tokenImage);
    }
  }

  /**
   * This method return name of the AQL file containing the error.
   * 
   * @return Erroneous AQL file name string; <code>null</code> if file name information is missing
   */
  public String getFileName() {
    return null; // AQL file info not available by now
  }

  /**
   * This method returns detailed error description, excluding error location.For error location
   * details please refer {@link #getFileName()}, {@link #getLine()} and {@link #getColumn()}
   * methods.
   * 
   * @return Error description string
   */
  public String getErrorDescription() {

    return this.errorDescription;
  }

  /**
   * This method returns the erroneous line number in the AQL file.
   * 
   * @return Erroneous line number; <code>0</code> if erroneous line number information missing
   */
  public int getLine() {
    return (this.erroneousLineNumber == 0) ? 0 : (this.erroneousLineNumber + lineAdjustment);
  }

  /**
   * This method return the column number in the erroneous line.
   * 
   * @return Erroneous column number; <code>0</code> if erroneous column number information missing
   */
  public int getColumn() {
    return this.erroneousColumnNumber;
  }

  /**
   * The end of line string for this machine.
   */
  protected String eol = System.getProperty("line.separator", "\n");

  /**
   * Used to convert raw characters to their escaped version when these raw version cannot be used
   * as part of an ASCII string literal.
   */
  static String add_escapes(String str) {
    StringBuffer retval = new StringBuffer();
    char ch;
    for (int i = 0; i < str.length(); i++) {
      switch (str.charAt(i)) {
        case 0:
          continue;
        case '\b':
          retval.append("\\b");
          continue;
        case '\t':
          retval.append("\\t");
          continue;
        case '\n':
          retval.append("\\n");
          continue;
        case '\f':
          retval.append("\\f");
          continue;
        case '\r':
          retval.append("\\r");
          continue;
        case '\"':
          retval.append("\\\"");
          continue;
        case '\'':
          retval.append("\\\'");
          continue;
        case '\\':
          retval.append("\\\\");
          continue;
        default:
          if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
            String s = "0000" + Integer.toString(ch, 16);
            retval.append("\\u" + s.substring(s.length() - 4, s.length()));
          } else {
            retval.append(ch);
          }
          continue;
      }
    }
    return retval.toString();
  }

  protected String prepareErrorDescription(Token currentToken, int[][] expectedTokenSequences,
      String[] tokenImage) {
    StringBuffer expected = new StringBuffer();
    int maxSize = 0;
    for (int i = 0; i < expectedTokenSequences.length; i++) {
      if (maxSize < expectedTokenSequences[i].length) {
        maxSize = expectedTokenSequences[i].length;
      }
      for (int j = 0; j < expectedTokenSequences[i].length; j++) {
        expected.append(getTokenString(expectedTokenSequences[i][j], tokenImage)).append(' ');
      }
      if (expectedTokenSequences[i][expectedTokenSequences[i].length - 1] != 0
          && i != expectedTokenSequences.length - 1) {
        expected.append(", ");
      }
    }

    String retval = "Encountered ";
    Token tok = currentToken.next;
    for (int i = 0; i < maxSize; i++) {
      if (i != 0)
        retval += " ";
      if (tok.kind == 0) {
        retval += tokenImage[0];
        break;
      }
      retval += " " + getTokenString(tok.kind, tokenImage);
      retval += " \"";
      retval += add_escapes(tok.image);
      retval += " \"";
      tok = tok.next;
    }

    retval += ". ";
    if (expectedTokenSequences.length == 1) {
      retval += "Was expecting a: ";
    } else {
      retval += "Was expecting one of: ";
    }
    retval += expected.toString();

    return retval;
  }

  /**
   * Number of lines that we should adjust the line number with. This is helpful when working with
   * backward compatibile AQLs, since the regenerated genericModule AQLs have 2 additional lines
   * over the original non-modular AQL and hence line adjustment is necessary during error
   * reporting.
   * 
   * @param numLines Number of lines to adjust. Use negative numbers to subtract lines.
   */
  public void adjustLineNumber(int numLines) {
    this.lineAdjustment = numLines;
  }

  /**
   * Method to translate token kind, an integer representing the type of token, to a textual
   * representation.
   * 
   * @param tokenKind integer representing the type of token
   * @param tokenImage array of textual representation of token type, generated by parser
   * @return equivalent textual representation for the specified token type
   */
  private static String getTokenString(int tokenKind, String[] tokenImage) {
    String tokenString = userFriendlyTokenMap.get(tokenKind);
    if (null == tokenString) {
      tokenString = tokenImage[tokenKind];
    }
    return tokenString;
  }


}
/*
 * JavaCC - OriginalChecksum=aec9d1141816b9f30cc07b33c6ccb8f5 (do not edit this line)
 */

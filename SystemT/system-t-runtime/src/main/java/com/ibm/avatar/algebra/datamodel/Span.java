/*******************************************************************************
 * Copyright IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 *******************************************************************************/
package com.ibm.avatar.algebra.datamodel;

import com.ibm.avatar.algebra.base.MemoizationTable;
import com.ibm.avatar.algebra.util.lang.LangCode;
import com.ibm.avatar.algebra.util.string.StringUtils;
import com.ibm.avatar.algebra.util.tokenize.OffsetsList;
import com.ibm.avatar.logging.Log;

/**
 * Object that encapsulates a span over text.
 * 
 */
public class Span implements SpanText {

  private static final boolean debug = false;

  /**
   * The document text object on which this span is based.
   */
  private Text docText;

  /** Begin and end of the text region; set in the SpanPool class. */
  private int begin, end;

  /**
   * Cached text of this span; initialized on the first call to {@link #getText()}
   */
  private String cachedText;

  /**
   * Cached tokenization of *this* span, if applicable.
   */
  // Cached tokenization of *this* span (as generated by {@link FastTokenizer} ), if applicable.
  private OffsetsList cachedTokens;

  /**
   * Special value to represent the fact that a span has 0 tokens.
   */
  public static final int NO_TOKENS = -1;

  /**
   * Special value to represent an invalid offset. This means that someone has computed the offset
   * and determined that it is not on a token boundary. The offset is either in the middle of a
   * token, or in the middle of the span between two tokens. This has a different meaning than
   * {@link #TOKEN_OFFSET_NOT_COMPUTED}, which means that nobody attempted to compute the offset
   * yet.
   */
  public static final int NOT_A_TOKEN_OFFSET = -2;

  /**
   * Special value used in the constructor to reflect the fact that nobody attempted to compute the
   * token offset. Distinct from {@link #NOT_A_TOKEN_OFFSET}
   */
  public static final int TOKEN_OFFSET_NOT_COMPUTED = -3;

  /**
   * Token offset into the original document of the beginning of this span, if the span starts
   * exactly on the token boundary.
   */
  private int beginTok;

  private int endTok;

  /**
   * If this span is to be used as a Text object, the conversion only need to be done once. The
   * result is cached here.
   */
  private Text cachedConvertedTextObj;

  /**
   * Initializes the Span object over the text field of the input tuple.
   * 
   * @param docText the Text object this span is based on
   * @param begin begin offset of the span
   * @param end end offset of the span
   * @throws IllegalArgumentException if the begin offset is greater than the end offset, or the
   *         begin or end offsets are negative values
   * @throws RuntimeException if the input type is not a span
   */
  public void init(Text docText, int begin, int end) {
    this.docText = docText;

    reallyInit(begin, end);

    // Do some checks on the values we've just put into place.

    String doctext = getDocText();
    int doctextLen = doctext.length();

    if (begin < 0 || begin > doctextLen) {
      throw new IllegalArgumentException(String
          .format("Invalid begin value %d (must be from %d to %d)", begin, 0, doctextLen - 1));
    }
    if (end < 0 || end > doctextLen) {
      throw new IllegalArgumentException(
          String.format("Invalid end value %d (must be from %d to %d)", end, 0, doctextLen - 1));
    }
    // if (end < begin) { throw new IllegalArgumentException (String.format (
    // "Invalid begin (%s) > end (%s)", begin, end)); }

  }

  /**
   * Initialize the Span object without performing any validation checks.
   * 
   * @param begin begin offset of the span
   * @param end end offset of the span
   */
  protected void reallyInit(int begin, int end) {
    // Internal sanity checks

    this.begin = begin;
    this.end = end;

    // Set up default values for other fields -- the caller may be reusing
    // this Span object.
    this.cachedText = null;
    this.cachedTokens = null;
    if (debug)
      Log.debug("Span.reallyInit(): %s - beginTok = %d", this, TOKEN_OFFSET_NOT_COMPUTED);
    this.beginTok = TOKEN_OFFSET_NOT_COMPUTED;
    this.endTok = TOKEN_OFFSET_NOT_COMPUTED;
  }

  /**
   * Returns the begin offset of this span over the underlying text.
   * 
   * @return Begin offset of the span over the text
   */
  public int getBegin() {
    return begin;
  }

  /**
   * Returns the end offset of this span over the underlying text.
   * 
   * @return End offset of span over the text
   */
  public int getEnd() {
    return end;
  }

  /**
   * Returns the index of the first token of the span in the list of tokens of the underlying text.
   * 
   * @return index of first token of the span
   */
  public int getBeginTok() {
    return beginTok;
  }

  /**
   * Returns the index of the last token of the span in the list of tokens of the underlying text.
   * 
   * @return index of last token of the span
   */
  public int getEndTok() {
    return endTok;
  }

  /**
   * Set the begin token index of the the span in the list of tokens of the underlying text.
   * 
   * @param beginTok
   */
  public void setBeginTok(int beginTok) {
    if (debug)
      Log.debug("Span.setBeginTok(): %s - beginTok = %d", this, beginTok);
    this.beginTok = beginTok;
  }

  /**
   * Set the end token index of the span in the list of tokens of the underlying text.
   * 
   * @param endTok
   */
  public void setEndTok(int endTok) {
    if (debug)
      Log.debug("Span.setEndTok(): %s - endTok = %d", this, endTok);
    this.endTok = endTok;
  }

  /**
   * This method returns the textual content of this span.
   * 
   * @return text between the span's begin and end offsets in the document text
   */
  @Override
  public String getText() {
    if (null == cachedText) {
      cachedText = getDocText().substring(begin, end);
    }
    return cachedText;
  }

  /**
   * Returns <code>true</code> if this span is over text that is derived from another source.
   * 
   * @return <code>true </code>if this span is over text that is derived from another source, with
   *         offset remapping available via
   *         {@link com.ibm.avatar.algebra.datamodel.Span#makeRemappedSpan(Span)}
   */
  public boolean getIsDerived() {
    return getDocTextObj().getIsDerived();
  }

  public OffsetsList getCachedTokens() {
    return cachedTokens;
  }

  public void resetCachedTokens() {
    cachedTokens = null;
  }

  public void setCachedTokens(OffsetsList cachedTokens) {
    this.cachedTokens = cachedTokens;
  }

  /**
   * Returns the language of the text of this span.
   * 
   * @return {@link LangCode} of the text of this span
   */
  @Override
  public LangCode getLanguage() {
    // Defer to the base text for language information.
    return getDocTextObj().getLanguage();
  }

  /**
   * Returns the document text over which this span is evaluated.
   * 
   * @return the document text over which this span is evaluated
   */
  @Override
  public String getDocText() {
    return getDocTextObj().getText();
  }

  /**
   * Returns the Text object that wraps the span's document text.
   * 
   * @return the Text object that wraps the span's document text
   */
  @Override
  public Text getDocTextObj() {
    return docText;
  }

  /**
   * Compare two Span objects, according to the following list of rules. These rules are examined in
   * the given order, and first unequal result is returned.
   * <ul>
   * <li>A null object is ordered lower than other objects.
   * <li>The objects are compared by the order of their docText objects.
   * <li>The objects are compared by the order of their begin offsets.
   * <li>The objects are compared by the order of their end offsets.
   * </ul>
   * 
   * @param other the span to be compared against the current span
   * @return 1 if the current span sorts higher than the input span, -1 if the input span sorts
   *         higher than the current span, 0 if they are equal
   */
  @Override
  public int compareTo(SpanText other) {
    // Text object ranked lower than span objects
    if (other instanceof Text) {
      return 1;
    }
    Span otherSpan = (Span) other;

    // short-cut
    if (otherSpan == this)
      return 0;

    // check if the other is null
    if (null == otherSpan)
      return 1;

    // Compare their docText objects
    int ret = this.getDocTextObj().compareTo(otherSpan.getDocTextObj());
    if (ret != 0)
      return ret;

    // Compare their begin offsets
    ret = begin - otherSpan.begin;
    if (ret != 0)
      return ret;

    // Compare their end offsets
    ret = end - otherSpan.end;
    return ret;

  }

  @Override
  public int hashCode() {
    int ret = begin + (end << 5) + getDocTextObj().hashCode();

    // Log.debug("%s hashes to %d\n", toString(), ret);

    return ret;
  }

  @Override
  public boolean equals(Object obj) {
    if (obj instanceof Span) {
      return (0 == compareTo((Span) obj));
    } else {
      return false;
    }
  }

  @Override
  public String toString() {
    // Get the text onto one line.
    // CharSequence shortenedText = StringUtils.shortenForPrinting (getText(), 40);
    // CharSequence shortenedText =
    // StringUtils.escapeForPrinting (TestUtils.shorten (getText (), 40, false));
    CharSequence shortenedText = shorten(getText(), 40, true);

    // Use StringBuilder for performance; this method gets called a lot in the UI
    // return String.format ("[%d-%d]: '%s'", begin, end, shortenedText);
    StringBuilder sb = new StringBuilder();
    sb.append('[');
    sb.append(begin);
    sb.append('-');
    sb.append(end);
    sb.append("]: '");
    sb.append(shortenedText);
    sb.append('\'');
    return sb.toString();
  }

  /**
   * Utility function to shorten a string to at most the indicated length, optionally escaping
   * newlines. TODO: This should be replaced by or merged with StringUtils.shorten. It is moved here
   * from TestUtils for Q4 2013. This is different from StringUtils.shorten, and affect many tests.
   */
  private static String shorten(String in, int maxlen, boolean stripNewlines) {
    if (stripNewlines) {
      in = in.replace("\n", "\\n");
      in = in.replace("\r", "\\r");
    }

    if (maxlen >= in.length()) {
      return in;
    } else {
      String ellipsis = "...";
      String head = in.substring(0, (maxlen - ellipsis.length()));
      return head + ellipsis;
    }
  }

  /**
   * Make a span over the original document, as opposed to a span within another span.
   * 
   * @param src span over the same text you want to create a span over
   * @param begin offset into the *document* text
   * @param end offset into the *document* text
   * @return a new span over the given input span
   */
  public static Span makeBaseSpan(Span src, int begin, int end) {
    return makeSpan(src.getDocTextObj(), begin, end);
  }

  /**
   * Make a span over a text object
   * 
   * @param src span over the same text you want to create a span over
   * @param begin offset into the *document* text
   * @param end offset into the *document* text
   * @return a new span over the given input span
   */
  public static Span makeBaseSpan(Text src, int begin, int end) {
    return makeSpan(src, begin, end);
  }

  /**
   * Make a span over another span. The new span must be completely contained within the original
   * span.
   * 
   * @param src span over the same text you want to create a span over
   * @param begin offset into the source span's text
   * @param end offset into the source span's text
   * @return a new span over the given input span
   */
  public static Span makeSubSpan(Span src, int begin, int end) {
    if (begin < 0) {
      throw new IllegalArgumentException(
          String.format("Error creating subspan of %s : begin offset %d must be non-negative.",
              src.toString(), begin));
    }

    if (src.getBegin() + end > src.getEnd()) {
      throw new IllegalArgumentException(String.format(
          "Error creating subspan of %s with offsets %d, %d : end offset %d is outside the original span.",
          src.toString(), begin, end, end));
    }

    // additional checks on begin and end happen inside the following call to makeSpan
    return makeSpan(src.getDocTextObj(), src.getBegin() + begin, src.getBegin() + end);
  }

  /**
   * Create a new span by remapping the offsets of a span over a derived string back to the original
   * string.
   * 
   * @param derivedSpan span over a string that was derived by performing some transformation (HTML
   *        detag, substring, etc.) over a string
   * @return a new span over the original source (original HTML, full string, etc.) of the string
   *         that derivedSpan references
   */
  public static Span makeRemappedSpan(Span derivedSpan) {

    if (!derivedSpan.getIsDerived()) {
      if (debug)
        Log.debug("Calling Remap on a Span not based on a derived Text object");
      return derivedSpan;
    }
    // Translate the input span's offsets.
    Text derivedText = derivedSpan.getDocTextObj();
    Text origText = derivedText.getSource();

    int begin = derivedText.translateOffset(derivedSpan.getBegin());

    // Find the offset of the *last* character in the input span, then set
    // the end of the new span one character beyond that
    int end;
    if (derivedSpan.getBegin() == derivedSpan.getEnd()) {
      // SPECIAL CASE: Zero-length span
      end = begin; // derived span length == remap span length
      // END SPECIAL CASE
    } else {
      end = 1 + derivedText.translateOffset(derivedSpan.getEnd() - 1);
    }

    return Span.makeSpan(origText, begin, end);
  }

  /**
   * Factory method for creating Span objects.
   * 
   * @param docText the document text object on which this span is based on.
   * @param begin begin offset within the base text where the span should begin
   * @param end end offset
   * @return a newly constructed span
   */
  public static Span makeSpan(Text docText, int begin, int end) {
    Span ret = new Span();

    if (begin > end) {
      throw new RuntimeException(String.format("Tried to create span from %d to %d", begin, end));
    }

    ret.init(docText, begin, end);

    return ret;
  }

  /**
   * Returns true if the given spans overlap. Spans with unequal docText are considered
   * non-overlapping
   * 
   * @return boolean indicating whether the given spans overlap
   */
  public static boolean overlaps(Span span1, Span span2) {

    // Spans on different document tuples cannot overlap
    if (false == span1.hasSameDocText(span2)) {
      return false;
    }

    // Spans overlap if one begins inside the other or they are the same span.
    if (span1.getBegin() >= span2.getBegin() && span1.getBegin() < span2.getEnd()) {
      return true;
    } else if (span2.getBegin() >= span1.getBegin() && span2.getBegin() < span1.getEnd()) {
      return true;
    } else if (span1.getBegin() == span2.getBegin() && span1.getEnd() == span2.getEnd()) {
      return true;
    } else {
      return false;
    }
  }



  /**
   * Returns true if this span contains the other span. Spans with unequal docText do not contain
   * each other.
   * 
   * @param otherSpan The other span to be compared with this span.
   * @return boolean indicating whether this span contains the other span
   */
  public boolean contains(Span otherSpan) {

    // Spans on different document tuples cannot contain each other
    if (!this.hasSameDocText(otherSpan)) {
      return false;
    }

    // Span1 contains span2 if its interval contains span2, inclusive of the boundary.
    return (this.getBegin() <= otherSpan.getBegin() && this.getEnd() >= otherSpan.getEnd());
  }


  /**
   * Removes any leading or trailing whitespace from this span. Analogous to
   * {@link StringUtils#chomp(CharSequence)}.
   * 
   * @return a span contained within this span, with no leading or trailing whitespace
   */
  @Override
  public Span chomp() {

    CharSequence text = getDocText();

    // Trim off whitespace by first moving the beginning of the span
    // forward, then moving the end back.
    int begin = getBegin();
    int end = getEnd();

    // System.err.printf("Chomping %s\n", this);

    while (begin < end && Character.isWhitespace(text.charAt(begin))) {
      begin++;
      // System.err.printf("Set begin to %d\n", begin);
    }

    while (begin < end && Character.isWhitespace(text.charAt(end - 1))) {
      end--;
    }

    return makeBaseSpan(getDocTextObj(), begin, end);
  }

  public static Span makeSubSpan(SpanText inputSpan, int begin, int end) {
    if (inputSpan instanceof Span) {
      return makeSubSpan((Span) inputSpan, begin, end);
    } else if (inputSpan instanceof Text) {
      return makeBaseSpan((Text) inputSpan, begin, end);
    } else {
      // Should not reach here
      return null;
    }
  }

  /**
   * Generate a text object from this span object. The object is cached for reuse. The reference to
   * docTextObj will be lost.
   * 
   * @return generated text object from this span
   */
  public Text toText() {
    if (null == this.cachedConvertedTextObj) {
      cachedConvertedTextObj = new Text(getText(), getLanguage());
    }
    return cachedConvertedTextObj;
  }

  /**
   * Convert a text object to a span object. If the input is already a span, return it. For all
   * other objects a type cast exception will be thrown. Use it only when you know the input is
   * either Text or Span. <br>
   * If the input to this method is null, return null.
   * 
   * @param source String, Span, or Text object to be converted to a span
   * @return Span object converted from source
   */
  public static Span convert(Object source) {
    if (source instanceof Text)
      return ((Text) source).toSpan();

    if (source instanceof String)
      return Text.fromString((String) source).toSpan();

    return (Span) source;
  }

  @Override
  public int getLength() {
    return this.end - this.begin;
  }

  /*
   * (non-Javadoc)
   * 
   * @see com.ibm.avatar.algebra.datamodel.SpanText#getLemma(com.ibm.avatar.algebra.base.
   * MemoizationTable)
   */
  @Override
  public String getLemma(MemoizationTable mt) {
    if (!mt.getTokenizer().supportLemmatization()) {
      throw new RuntimeException(
          "The tokenizer does not support lemmatization that is required by GetLemma function");
    }

    if (debug)
      Log.debug("---------------------GetLemma---------------------");

    mt.getTokenizer().tokenize(this);

    // cachedTokens can't be null
    // and if this is a Span not a Text, beginTok and endTok have to be computed by now
    // for Text, beginTok is 0 and endTok is size()-1 so they have to be computed
    if ((cachedTokens == null))
      throw new RuntimeException("Tokenization failed in GetLemma function");

    OffsetsList tokens = cachedTokens;
    int _startToken, _endToken;
    _startToken = 0;
    _endToken = tokens.size() - 1;

    String first_partial = "";
    String last_partial = "";
    StringBuilder lemmaStr = new StringBuilder();
    if (this.beginTok == NOT_A_TOKEN_OFFSET) {
      int begin_of_first_token = this.begin + tokens.begin(_startToken);
      if (begin_of_first_token <= this.begin) {
        // the first partial part is non-whitespace
        first_partial = getDocText().substring(this.begin, this.begin + tokens.end(_startToken));
        lemmaStr.append(first_partial);
        _startToken++;
      } else {
        // whitespace, do nothing here
      }
    }
    if (this.endTok == NOT_A_TOKEN_OFFSET) {
      int end_of_last_token = this.begin + tokens.end(_endToken);
      if (end_of_last_token >= this.end) {
        // the last partial part is non-whitespace
        last_partial = getDocText().substring(this.begin + tokens.begin(_endToken), this.end);
        _endToken--;
      } else {
        // the last part is whitespace, do nothing here
      }
    }

    if (debug) {
      Log.debug("tokens: start=%d end=%d size=%d", _startToken, _endToken, tokens.size());
      Log.debug("first partial='%s'\nlast partial='%s'", first_partial, last_partial);
    }

    for (int tokenIndex = _startToken; tokenIndex <= _endToken; tokenIndex++) {
      if (lemmaStr.length() > 0)
        lemmaStr.append(" ");
      String lemma = tokens.getLemma(tokenIndex);
      lemma = lemma.replaceAll(" ", "\\\\ ");// escape whitespaces inside a lemma
      if (debug)
        Log.debug("%d %s", tokenIndex, lemma);
      lemmaStr.append(lemma);
    }
    if (last_partial.length() > 0) {
      if (lemmaStr.length() > 0)
        lemmaStr.append(" ");
      lemmaStr.append(last_partial);
    }

    if (debug) {
      Log.debug("input: '%s'\nlemma: '%s'", getText(), lemmaStr);
      Log.debug("--------------------------------------------------\n\n");
      Log.disableAllMsgTypes();
    }

    return lemmaStr.toString();
  }

  /**
   * Returns true if this span and the other span has the same docText object
   * 
   * @param other
   * @return
   */
  public boolean hasSameDocText(Span other) {
    return this.getDocTextObj().equals(other.getDocTextObj());
  }
}

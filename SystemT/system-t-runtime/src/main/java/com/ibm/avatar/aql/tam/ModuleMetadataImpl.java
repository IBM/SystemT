/*******************************************************************************
 * Copyright IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 *******************************************************************************/
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
// Implementation, vJAXB 2.1.10 in
// JDK 6
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
// Any modifications to this file will be lost upon recompilation of the source schema.
// Generated on: 2012.06.19 at 04:26:09 PM IST
//

package com.ibm.avatar.aql.tam;

import java.io.InputStream;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.List;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Unmarshaller;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlType;

import com.ibm.avatar.algebra.datamodel.Pair;
import com.ibm.avatar.algebra.datamodel.TupleSchema;
import com.ibm.avatar.algebra.util.string.StringUtils;
import com.ibm.avatar.algebra.util.tokenize.Tokenizer;
import com.ibm.avatar.api.Constants;
import com.ibm.avatar.api.exceptions.FatalInternalError;
import com.ibm.avatar.api.exceptions.InvalidModuleElementException;
import com.ibm.avatar.api.tam.DictionaryMetadata;
import com.ibm.avatar.api.tam.FunctionMetadata;
import com.ibm.avatar.api.tam.ModuleMetadata;
import com.ibm.avatar.api.tam.TableMetadata;
import com.ibm.avatar.api.tam.ViewMetadata;
import com.ibm.avatar.aql.doc.AQLDocComment;
import com.ibm.biginsights.textanalytics.util.ObjectComparator;

/**
 * JAXB class for module metadata. The XML equivalent of this class is the top level
 * &lt;module-metadata&gt; tag.
 * </pre>
 */
@XmlRootElement(name = "module-metadata")
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "ModuleMetadataImpl", namespace = "http://www.ibm.com/aql",
    propOrder = {"comment", "requiredModules", "dictionaries", "views", "tables", "functions"})
public class ModuleMetadataImpl extends AbstractTAMComponent implements ModuleMetadata {
  private static final long serialVersionUID = -3090187068666118714L;

  @XmlElement(required = true)
  protected ModuleMetadataImpl.Dictionaries dictionaries;
  @XmlElement(required = true)
  protected ModuleMetadataImpl.Views views;
  @XmlElement(required = true)
  protected ModuleMetadataImpl.Tables tables;
  @XmlElement(required = true)
  protected ModuleMetadataImpl.Functions functions;
  @XmlAttribute(name = "module-name")
  protected String moduleName;
  @XmlAttribute
  protected String compilationTime;
  @XmlAttribute
  protected String hostName;
  @XmlAttribute
  protected String userName;
  @XmlAttribute
  protected String productVersion;

  /**
   * The comment for the module, as read from the
   * {@link AQLDocComment#MODULE_AQL_DOC_COMMENT_FILE_NAME} file in the module directory.
   */
  @XmlElement
  protected CommentType comment;

  /**
   * Comma separated list of module names that the current module depends on
   */
  @XmlAttribute
  protected String dependsOn;

  @XmlElement(required = false)
  protected ModuleMetadataImpl.RequiredModules requiredModules;

  /**
   * Tokenizer used for compiling the current module. <br/>
   * Possible values: {@link Constants#TKNZR_TYPE_STANDARD} or
   * {@link Constants#TKNZR_TYPE_MULTILINGUAL} <br/>
   */
  @XmlAttribute
  protected String tokenizerType;

  private static JAXBContext jaxbContext;

  /**
   * Gets the value of the dictionaries property.
   * 
   * @return possible object is {@link ModuleMetadataImpl.Dictionaries }
   */
  public ModuleMetadataImpl.Dictionaries getDictionaries() {
    return dictionaries;
  }

  /**
   * Sets the value of the dictionaries property.
   * 
   * @param value allowed object is {@link ModuleMetadataImpl.Dictionaries }
   */
  public void setDictionaries(ModuleMetadataImpl.Dictionaries value) {
    this.dictionaries = value;
  }

  /**
   * Gets the value of the views property.
   * 
   * @return possible object is {@link ModuleMetadataImpl.Views }
   */
  public ModuleMetadataImpl.Views getViews() {
    return views;
  }

  /**
   * Sets the value of the views property.
   * 
   * @param value allowed object is {@link ModuleMetadataImpl.Views }
   */
  public void setViews(ModuleMetadataImpl.Views value) {
    this.views = value;
  }

  /**
   * Gets the value of the tables property.
   * 
   * @return possible object is {@link ModuleMetadataImpl.Tables }
   */
  public ModuleMetadataImpl.Tables getTables() {
    return tables;
  }

  /**
   * Sets the value of the tables property.
   * 
   * @param value allowed object is {@link ModuleMetadataImpl.Tables }
   */
  public void setTables(ModuleMetadataImpl.Tables value) {
    this.tables = value;
  }

  /**
   * Gets the value of the functions property.
   * 
   * @return possible object is {@link ModuleMetadataImpl.Functions }
   */
  public ModuleMetadataImpl.Functions getFunctions() {
    return functions;
  }

  /**
   * Sets the value of the functions property.
   * 
   * @param value allowed object is {@link ModuleMetadataImpl.Functions }
   */
  public void setFunctions(ModuleMetadataImpl.Functions value) {
    this.functions = value;
  }

  // /**
  // * Gets the value of the docType property.
  // *
  // * @return possible object is {@link SchemaType }
  // */
  // public SchemaType getDocType ()
  // {
  // return docType;
  // }

  // /**
  // * Sets the value of the docType property.
  // *
  // * @param value allowed object is {@link SchemaType }
  // */
  // public void setDocType (SchemaType value)
  // {
  // this.docType = value;
  // }

  // /**
  // * Sets the document schema of the current module
  // * @param docSchema
  // */
  // public void setDocSchema (TupleSchema docSchema)
  // {
  // SchemaType schema = new SchemaType ();
  // schema.column = new ArrayList<SchemaType.Column> ();
  //
  // String colNames[] = docSchema.getFieldNames ();
  // FieldType colTypes[] = docSchema.getFieldTypes ();
  //
  // for (int i = 0; i < colNames.length; ++i) {
  // Column col = new Column ();
  // col.name = colNames[i];
  // col.type = colTypes[i].getTypeName ();
  // schema.column.add (col);
  // }
  //
  // setDocType (schema);
  //
  // }

  /**
   * Gets the value of the moduleName property.
   * 
   * @return possible object is {@link String }
   */
  @Override
  public String getModuleName() {
    return moduleName;
  }

  /**
   * Sets the value of the moduleName property.
   * 
   * @param value allowed object is {@link String }
   */
  public void setModuleName(String value) {
    this.moduleName = value;
  }

  /**
   * Gets the value of the compilationTime property.
   * 
   * @return possible object is {@link String }
   */
  @Override
  public String getCompilationTime() {
    return compilationTime;
  }

  /**
   * Sets the value of the compilationTime property.
   * 
   * @param value allowed object is {@link String }
   */
  public void setCompilationTime(String value) {
    this.compilationTime = value;
  }

  /**
   * JAXB class for the &lt;dictionaries&gt; element under &lt;module-metadata&gt;
   */
  @XmlAccessorType(XmlAccessType.FIELD)
  @XmlType(name = "", propOrder = {"dict"})
  public static class Dictionaries implements Serializable {
    private static final long serialVersionUID = 4397932736119735628L;

    protected List<DictionaryMetadataImpl> dict;

    /**
     * Gets the value of the dict property.
     * <p>
     * This accessor method returns a reference to the live list, not a snapshot. Therefore any
     * modification you make to the returned list will be present inside the JAXB object. This is
     * why there is not a <CODE>set</CODE> method for the dict property.
     * <p>
     * For example, to add a new item, do as follows:
     * 
     * <pre>
     * getDict().add(newItem);
     * </pre>
     * <p>
     * Objects of the following type(s) are allowed in the list {@link DictionaryMetadataImpl }
     */
    public List<DictionaryMetadataImpl> getDict() {
      if (dict == null) {
        dict = new ArrayList<DictionaryMetadataImpl>();
      }
      return this.dict;
    }

    @Override
    public boolean equals(Object obj) {
      if (obj == null)
        return false;

      if (false == obj instanceof Dictionaries)
        return false;

      Dictionaries other = (Dictionaries) obj;
      return ObjectComparator.equals(this.dict, other.dict);

    }

    @Override
    public int hashCode() {
      throw new FatalInternalError("Hashcode not implemented for class %s.",
          this.getClass().getSimpleName());
    }

    @Override
    public String toString() {
      StringBuilder buf = new StringBuilder();
      buf.append("{\n");
      for (DictionaryMetadata dictMetadata : dict) {
        buf.append(String.format("\t[%s]", dictMetadata.toString()));
      }
      buf.append("\n}");

      return buf.toString();
    }
  }

  /**
   * JAXB class for the &lt;functions&gt; element under &lt;module-metadata&gt;
   */
  @XmlAccessorType(XmlAccessType.FIELD)
  @XmlType(name = "", propOrder = {"function"})
  public static class Functions implements Serializable {

    private static final long serialVersionUID = -2319609051676374188L;

    protected List<FunctionMetadataImpl> function;

    /**
     * Gets the value of the function property.
     * <p>
     * This accessor method returns a reference to the live list, not a snapshot. Therefore any
     * modification you make to the returned list will be present inside the JAXB object. This is
     * why there is not a <CODE>set</CODE> method for the function property.
     * <p>
     * For example, to add a new item, do as follows:
     * 
     * <pre>
     * getFunction().add(newItem);
     * </pre>
     * <p>
     * Objects of the following type(s) are allowed in the list {@link FunctionMetadataImpl }
     */
    public List<FunctionMetadataImpl> getFunction() {
      if (function == null) {
        function = new ArrayList<FunctionMetadataImpl>();
      }
      return this.function;
    }

    @Override
    public boolean equals(Object obj) {
      if (obj == null)
        return false;

      if (false == obj instanceof Functions)
        return false;

      Functions other = (Functions) obj;
      return ObjectComparator.equals(this.function, other.function);

    }

    @Override
    public int hashCode() {
      throw new FatalInternalError("Hashcode not implemented for class %s.",
          this.getClass().getSimpleName());
    }

    @Override
    public String toString() {
      StringBuilder buf = new StringBuilder();
      buf.append("{\n");
      for (FunctionMetadata funcMetadata : function) {
        buf.append(String.format("\t[%s]", funcMetadata.toString()));
      }
      buf.append("\n}");

      return buf.toString();
    }

  }

  /**
   * JAXB class for the &lt;tables&gt; element under &lt;module-metadata&gt;
   */
  @XmlAccessorType(XmlAccessType.FIELD)
  @XmlType(name = "", propOrder = {"table"})
  public static class Tables implements Serializable {

    private static final long serialVersionUID = 3026704757538310818L;

    protected List<TableMetadataImpl> table;

    /**
     * Gets the value of the table property.
     * <p>
     * This accessor method returns a reference to the live list, not a snapshot. Therefore any
     * modification you make to the returned list will be present inside the JAXB object. This is
     * why there is not a <CODE>set</CODE> method for the table property.
     * <p>
     * For example, to add a new item, do as follows:
     * 
     * <pre>
     * getTable().add(newItem);
     * </pre>
     * <p>
     * Objects of the following type(s) are allowed in the list {@link TableMetadataImpl }
     */
    public List<TableMetadataImpl> getTable() {
      if (table == null) {
        table = new ArrayList<TableMetadataImpl>();
      }
      return this.table;
    }

    @Override
    public boolean equals(Object obj) {
      if (obj == null)
        return false;

      if (false == obj instanceof Tables)
        return false;

      Tables other = (Tables) obj;
      return ObjectComparator.equals(this.table, other.table);

    }

    @Override
    public int hashCode() {
      throw new FatalInternalError("Hashcode not implemented for class %s.",
          this.getClass().getSimpleName());
    }

    @Override
    public String toString() {
      StringBuilder buf = new StringBuilder();
      buf.append("{\n");
      for (TableMetadata tableMetadata : table) {
        buf.append(String.format("\t[%s]", tableMetadata.toString()));
      }
      buf.append("\n}");

      return buf.toString();
    }


  }

  /**
   * JAXB class for the &lt;views&gt; element under &lt;module-metadata&gt;
   */
  @XmlAccessorType(XmlAccessType.FIELD)
  @XmlType(name = "", propOrder = {"view"})
  public static class Views implements Serializable {

    private static final long serialVersionUID = 7775844807206672117L;

    protected List<ViewMetadataImpl> view;

    /**
     * Gets the value of the view property.
     * <p>
     * This accessor method returns a reference to the live list, not a snapshot. Therefore any
     * modification you make to the returned list will be present inside the JAXB object. This is
     * why there is not a <CODE>set</CODE> method for the view property.
     * <p>
     * For example, to add a new item, do as follows:
     * 
     * <pre>
     * getView().add(newItem);
     * </pre>
     * <p>
     * Objects of the following type(s) are allowed in the list {@link ViewMetadataImpl }
     */
    public List<ViewMetadataImpl> getView() {
      if (view == null) {
        view = new ArrayList<ViewMetadataImpl>();
      }
      return this.view;
    }

    @Override
    public boolean equals(Object obj) {
      if (obj == null)
        return false;

      if (false == obj instanceof Views)
        return false;

      Views other = (Views) obj;
      return ObjectComparator.equals(this.view, other.view);

    }

    @Override
    public int hashCode() {
      throw new FatalInternalError("Hashcode not implemented for class %s.",
          this.getClass().getSimpleName());
    }

    @Override
    public String toString() {
      StringBuilder buf = new StringBuilder();
      buf.append("{\n");
      for (ViewMetadata viewMetadata : view) {
        buf.append(String.format("\t[%s]", viewMetadata.toString()));
      }
      buf.append("\n}");

      return buf.toString();
    }
  }

  @Override
  public String getFileName() {
    return "metadata.xml";
  }

  /**
   * Return the schema of the view Document, as declared in this module.
   */
  @Override
  public TupleSchema getDocSchema() {
    return getViewMetadata(Constants.DEFAULT_DOC_TYPE_NAME).getViewSchema();
  }

  @Override
  public List<Pair<String, String>> getExternalViews() {
    ArrayList<Pair<String, String>> extViews = new ArrayList<Pair<String, String>>();
    if (views.view != null) {
      for (ViewMetadata viewMetadata : views.view) {
        if (viewMetadata.isExternal()) {
          String aqlName = ModuleUtils.prepareQualifiedName(getViewModuleName(viewMetadata),
              viewMetadata.getViewName());
          String externalName = viewMetadata.getExternalName();
          Pair<String, String> extView = new Pair<String, String>(aqlName, externalName);
          extViews.add(extView);
        }
      }
    }
    return extViews;
  }

  @Override
  public String[] getExportedViews() {
    ArrayList<String> exportedViews = new ArrayList<String>();
    if (views.view != null) {
      for (ViewMetadata viewMetadata : views.view) {
        if (viewMetadata.isExported()) {
          exportedViews.add(ModuleUtils.prepareQualifiedName(getViewModuleName(viewMetadata),
              viewMetadata.getViewName()));
        }
      }
    }
    return exportedViews.toArray(new String[0]);
  }

  @Override
  public String[] getOutputViews() {
    ArrayList<String> outputViews = new ArrayList<String>();

    if (views.view != null) {
      for (ViewMetadata viewMetadata : views.view) {
        if (viewMetadata.isOutputView()) {
          // Output view alias is the first choice
          String viewRef = viewMetadata.getOutputAlias();
          // If output alias is null - return qualified names
          if (null == viewRef) {
            viewRef = ModuleUtils.prepareQualifiedName(getViewModuleName(viewMetadata),
                viewMetadata.getViewName());
          }
          outputViews.add(viewRef);
        }
      }
    }
    return outputViews.toArray(new String[0]);
  }

  @Override
  public ViewMetadata getViewMetadata(String viewName) {
    if (viewName == null) {
      return null;
    }

    ViewMetadata match = null;

    // Flag to signal that a match is already found.
    // For multiple matches we throw exception; this is a corner, probably this won't occur ever.
    boolean matchFound = false;

    // Error message to be used if there are multiple matches
    String errMsg = "Ambiguity while looking up for view meta-data.";

    if (views.view != null) {
      /*
       * Given argument(viewName) can be one of the following: (1) output alias as defined in
       * 'output view ...' statement, (2) fully qualified view name, (3) unqualified view name, if
       * the view belong to genericModule or in built Document view (4) external name as defined in
       * 'create external view ...' statement. We perform the lookup for given argument in passes -
       * refer defect (comment#6)
       */

      // Pass 1: lookup against the outputAlias attribute of view meta-data
      for (ViewMetadata viewMetadata : views.view) {
        // Given view name can be output alias or fully qualified view name
        if (viewName.equals(viewMetadata.getOutputAlias())) {
          match = viewMetadata;
          matchFound = true;
        }
      }

      // Pass 2: For genericModule module or view name Document - perform lookup against unqualified
      // view name (viewName
      // attribute). For other modules lookup should be performed against qualified name
      for (ViewMetadata viewMetadata : views.view) {
        // lookup against unqualified name
        if (Constants.GENERIC_MODULE_NAME.equals(getModuleName())
            || viewName.equals(Constants.DEFAULT_DOC_TYPE_NAME)) {
          if (viewName.equals(viewMetadata.getViewName())) {

            if (true == matchFound) {
              String updatedErrMsg = String.format(
                  "%s Given name '%s' used as output alias for view '%s', and also as a un-qualified name for output view '%s'.",
                  errMsg, viewName, match.getViewName(), viewMetadata.getViewName());
              throw new RuntimeException(updatedErrMsg);
            } else {
              match = viewMetadata;
              matchFound = true;
            }
          }
        } else { // lookup against prepared qualified name
          String qName = ModuleUtils.prepareQualifiedName(getViewModuleName(viewMetadata),
              viewMetadata.getViewName());

          if (viewName.equals(qName)) {
            if (true == matchFound) {
              String updatedErrMsg = String.format(
                  "%s Given name '%s' used as output alias for view '%s', and also as a qualified name for exported or output view '%s'.",
                  errMsg, viewName, match.getViewName(), viewMetadata.getViewName());
              throw new RuntimeException(updatedErrMsg);
            } else {
              match = viewMetadata;
              matchFound = true;
            }
          }
        }
      }

      // Pass 3: lookup against externalName attribute of view meta-data - performed only for
      // external views
      for (ViewMetadata viewMetadata : views.view) {
        if (viewMetadata.isExternal() && viewName.equals(viewMetadata.getExternalName())) {
          if (true == matchFound) {
            String updatedErrMsg = String.format(
                "%s Given name '%s' used as qualified or un-qualified name for view '%s', and also as a external_name for external view '%s'.",
                errMsg, viewName, match.getViewName(), viewMetadata.getViewName());
            throw new RuntimeException(updatedErrMsg);
          } else {
            match = viewMetadata;
            matchFound = true;
          }
        }
      }
    }

    // Pass 4: Initialization before returning the metadata
    if (null != match) {
      ViewMetadataImpl viewMetadataImpl = (ViewMetadataImpl) match;

      // Compiler populates moduleName attribute of view meta-data only for non-local(imported)
      // views. Hence, before
      // returning view meta-data manually populating the module name
      if (null == match.getModuleName()) {
        viewMetadataImpl.setModuleName(getModuleName());
      }

      // For legacy TAMs, costRec might be null for certain types of views. So, initialize it with
      // empty cost record to
      // avoid NPEs
      if (viewMetadataImpl.getCostRec() == null) {
        viewMetadataImpl.setCostRec(new CostRecordType());
      }
    }

    return match;
  }

  @Override
  public String getComment(ElementType type, String name) throws InvalidModuleElementException {
    switch (type) {
      case VIEW: {
        ViewMetadata m = getViewMetadata(name);
        if (null == m)
          throw new InvalidModuleElementException(type, name);
        return m.getComment();
      }
      case TABLE: {
        TableMetadata m = getTableMetadata(name);
        if (null == m)
          throw new InvalidModuleElementException(type, name);
        return m.getComment();
      }
      case DICTIONARY: {
        DictionaryMetadata m = getDictionaryMetadata(name);
        if (null == m)
          throw new InvalidModuleElementException(type, name);
        return m.getComment();
      }
      case FUNCTION: {
        FunctionMetadata m = getFunctionMetadata(name);
        if (null == m)
          throw new InvalidModuleElementException(type, name);
        return m.getComment();
      }
      case MODULE: {
        return this.getComment();
      }
      default: {
        throw new InvalidModuleElementException(type, name);
      }

    }
  }

  @Override
  public String[] getExternalTables() {
    ArrayList<String> extTables = new ArrayList<String>();

    if (tables.table != null) {
      for (TableMetadata table : tables.table) {
        if (table.isExternal()) {
          extTables.add(ModuleUtils.prepareQualifiedName(getModuleName(), table.getTableName()));
        }
      }
    }
    return extTables.toArray(new String[0]);
  }

  @Override
  public String[] getExportedTables() {
    ArrayList<String> expTables = new ArrayList<String>();
    if (tables.table != null) {
      for (TableMetadata table : tables.table) {
        if (table.isExported()) {
          expTables.add(ModuleUtils.prepareQualifiedName(getModuleName(), table.getTableName()));
        }
      }
    }
    return expTables.toArray(new String[0]);
  }

  @Override
  public TableMetadata getTableMetadata(String tableName) {
    if (tableName == null) {
      return null;
    }

    if (tables.table != null) {
      for (TableMetadata tabMetadata : tables.table) {
        if (tableName.equals(
            ModuleUtils.prepareQualifiedName(getModuleName(), tabMetadata.getTableName()))) {
          return tabMetadata;
        }
      }
    }
    return null;
  }

  @Override
  public String[] getExternalDictionaries() {
    ArrayList<String> extDicts = new ArrayList<String>();
    if (dictionaries.dict != null) {
      for (DictionaryMetadata dict : dictionaries.dict) {
        if (dict.isExternal()) {
          extDicts.add(ModuleUtils.prepareQualifiedName(getModuleName(), dict.getDictName()));
        }
      }
    }
    return extDicts.toArray(new String[0]);
  }

  @Override
  public String[] getExportedDictionaries() {
    ArrayList<String> expDicts = new ArrayList<String>();
    if (dictionaries.dict != null) {
      for (DictionaryMetadata dict : dictionaries.dict) {
        if (dict.isExported()) {
          expDicts.add(ModuleUtils.prepareQualifiedName(getModuleName(), dict.getDictName()));
        }
      }
    }
    return expDicts.toArray(new String[0]);
  }

  @Override
  public DictionaryMetadata getDictionaryMetadata(String dictName) {
    if (dictName == null) {
      return null;
    }

    if (dictionaries.dict != null) {
      for (DictionaryMetadata dictMetadata : dictionaries.dict) {
        if (dictName.equals(
            ModuleUtils.prepareQualifiedName(getModuleName(), dictMetadata.getDictName()))) {
          return dictMetadata;
        }
      }
    }

    return null;
  }

  /**
   * Returns the list of function names, marked exported in the module.
   * 
   * @return names of exported function
   */
  @Override
  public String[] getExportedFunctions() {
    ArrayList<String> exportedFuncs = new ArrayList<String>();

    if (null == functions) {
      throw new FatalInternalError("\"functions\" field of ModuleMetadataImpl object is null.");
    }

    if (functions.function != null) {
      for (FunctionMetadata funcMetadata : functions.function) {
        if (funcMetadata.isExported()) {
          exportedFuncs.add(
              ModuleUtils.prepareQualifiedName(getModuleName(), funcMetadata.getFunctionName()));
        }
      }
    }
    return exportedFuncs.toArray(new String[0]);
  }

  @Override
  public FunctionMetadata getFunctionMetadata(String functionName) {
    if (functionName == null) {
      return null;
    }

    if (functions.function != null) {
      for (FunctionMetadata funcMetadata : functions.function) {
        if (functionName.equals(
            ModuleUtils.prepareQualifiedName(getModuleName(), funcMetadata.getFunctionName()))) {
          return funcMetadata;
        }
      }
    }

    return null;
  }

  /**
   * @return the hostName
   */
  @Override
  public String getHostName() {
    return hostName;
  }

  /**
   * @param hostName the hostName to set
   */
  public void setHostName(String hostName) {
    this.hostName = hostName;
  }

  /**
   * @return the userName
   */
  @Override
  public String getUserName() {
    return userName;
  }

  /**
   * @param userName the userName to set
   */
  public void setUserName(String userName) {
    this.userName = userName;
  }

  /**
   * @return the productVersion
   */
  @Override
  public String getProductVersion() {
    return productVersion;
  }

  /**
   * @param productVersion the productVersion to set
   */
  public void setProductVersion(String productVersion) {
    this.productVersion = productVersion;
  }

  public long getCompileTime() {
    return Long.valueOf(compilationTime).longValue();
  }

  /**
   * Gets the value of the comment property.
   * 
   * @return possible object is {@link CommentType }
   */
  @Override
  public String getComment() {
    if (null == comment)
      return null;
    return comment.getText();
  }

  /**
   * Sets the value of the comment property.
   * 
   * @param value allowed object is {@link CommentType }
   */
  public void setComment(CommentType value) {
    this.comment = value;
  }

  /**
   * Set the AQL doc comment string associated with this view. If the input comment exists, that is,
   * the file {@link AQLDocComment#MODULE_AQL_DOC_COMMENT_FILE_NAME} exists, we set the comment to
   * be a lightly cleaned up version of the original comment text, as provided by
   * {@link AQLDocComment#getCleanedText()}.
   * 
   * @param comment AQL doc comment associated with this statement in the AQL code
   */
  public void setComment(AQLDocComment comment) {
    if (null != comment) {
      this.comment = new CommentType();
      this.comment.setText(comment.getCleanText());
    }
  }

  /**
   * Returns the list of modules that the current module depends on, as a comma-separated list. If
   * <requiredModules> element is not found, it returns the value contained in 'dependsOn'
   * attribute.
   * 
   * @return the comma separated list of modules that the current module depends on
   * @deprecated As of v2.1, replaced by {@link #getDependentModules()}
   */
  @Deprecated
  @Override
  public String getDependsOn() {
    // Read the value of <requiredModules> element, if present.
    if (requiredModules != null) {
      return StringUtils.concatenate(getDependentModules(), Constants.COMMA);
    }
    // Read the value of dependsOn attribute if <requiredModules> is not present
    else {
      return dependsOn;
    }
  }

  /**
   * Sets the list of modules that the current module depends on.
   * 
   * @param dependsOn a comma separated list of module names
   * @deprecated As of v2.1, replaced by {@link #setDependentModules(List)}
   */
  @Deprecated
  public void setDependsOn(String dependsOn) {
    setDependentModules(StringUtils.convertToList(dependsOn, Constants.COMMA));
  }

  /**
   * Returns a list of module names that the current module depends on.
   * 
   * @return List of module names that the current module depends on
   */
  @Override
  public List<String> getDependentModules() {
    // if <requiredModules> is missing, then possibly return the contents of 'dependsOn' attribute
    // (or) return an empty
    // list to avoid NPEs
    if (null == requiredModules) {
      if (null != dependsOn) {
        return StringUtils.convertToList(dependsOn, Constants.COMMA);
      } else {
        return new ArrayList<String>();
      }
    } else {// <requiredModules> is present, so return the items.
      return requiredModules.getItem();
    }
  }

  /**
   * Sets the list of modules that the current module depends on.
   * 
   * @param list the list of module names that the current module depends on.
   */
  public void setDependentModules(List<String> list) {
    if (requiredModules == null) {
      requiredModules = new RequiredModules(list);
    } else {
      requiredModules.getItem().clear();
      requiredModules.getItem().addAll(list);
    }
  }

  /**
   * Getter used by JAXB to retrieve requiredModules attribute
   * 
   * @return the requiredModules
   */
  public ModuleMetadataImpl.RequiredModules getRequiredModules() {
    return requiredModules;
  }

  /**
   * Setter used by JAXB to set requiredModules attribute
   * 
   * @param requiredModules
   */
  public void setRequiredModules(ModuleMetadataImpl.RequiredModules requiredModules) {
    this.requiredModules = requiredModules;
  }

  public static ModuleMetadataImpl deserialize(InputStream in) throws JAXBException {
    if (jaxbContext == null) {
      jaxbContext = JAXBContext.newInstance(ModuleMetadataImpl.class);
    }

    Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();
    return (ModuleMetadataImpl) unmarshaller.unmarshal(in);
  }

  /**
   * Set the comment of the module.
   * 
   * @param comment a String representing the comment for the module, or <code>null</code> if there
   *        is no comment
   */
  public void setComment(String comment) {
    if (null != comment) {
      this.comment = new CommentType();
      this.comment.setText(comment);
    }
  }

  /**
   * Returns the tokenizer type used during compilation of this module
   * 
   * @return Tokenizer type used for compiling this module
   */
  @Override
  public String getTokenizerType() {
    return tokenizerType;
  }

  /**
   * Sets the tokenizerType used for compiling this module.
   * 
   * @param tokenizerType
   */
  public void setTokenizerType(String tokenizerType) {
    this.tokenizerType = tokenizerType;
  }

  /*
   * APIs for internal consumer: Runtime and Tooling code; these APIs can be accessed through
   * ModuleMetadataimpl class.
   */

  /**
   * Return view meta-data for the given unqualified view name.
   * 
   * @param uqViewName unqualified view name
   * @return view meta-data object
   */
  public ViewMetadata getViewMetadataByUQName(String uqViewName) {
    if (null == uqViewName) {
      return null;
    }

    if (null != views.view) {
      for (ViewMetadata viewMetadata : views.view) {
        if (uqViewName.equals(viewMetadata.getViewName())) {
          return viewMetadata;
        }
      }
    }
    return null;
  }

  /**
   * Return table meta-data for the given unqualified table name.
   * 
   * @param uqTableName unqualified table name
   * @return table meta-data object
   */
  public TableMetadata getTableMetadataByUQName(String uqTableName) {
    if (null == uqTableName) {
      return null;
    }

    if (null != tables.table) {
      for (TableMetadata tableMetadata : tables.table) {
        if (uqTableName.equals(tableMetadata.getTableName())) {
          return tableMetadata;
        }
      }
    }
    return null;
  }

  /**
   * Return dictionary meta-data for the given unqualified dictionary name.
   * 
   * @param uqDictName unqualified dictionary name
   * @return dictionary meta-data object
   */
  public DictionaryMetadata getDictionaryMetadataByUQName(String uqDictName) {
    if (null == uqDictName) {
      return null;
    }

    if (null != dictionaries.dict) {
      for (DictionaryMetadata dictMetadata : dictionaries.dict) {
        if (uqDictName.equals(dictMetadata.getDictName())) {
          return dictMetadata;
        }
      }
    }
    return null;
  }

  /**
   * Return function meta-data for the given unqualified function name.
   * 
   * @param uqFuncName unqualified function name
   * @return function meta-data object
   */
  public FunctionMetadata getFunctionMetadataByUQName(String uqFuncName) {
    if (null == uqFuncName) {
      return null;
    }

    if (null != functions.function) {
      for (FunctionMetadata funcMetadata : functions.function) {
        if (uqFuncName.equals(funcMetadata.getFunctionName())) {
          return funcMetadata;
        }
      }
    }
    return null;
  }

  /**
   * Returns list of dictionary names, marked coming from external table. This method is not exposed
   * to outer world, hence not part of ModuleMetadata interface.
   * 
   * @return names of dictionaries, whose entries are coming from external table
   */
  public String[] getDictComingFromExtTable() {
    ArrayList<String> dictComingFromExtTable = new ArrayList<String>();
    if (dictionaries.dict != null) {
      for (DictionaryMetadata dict : dictionaries.dict) {
        if (false == dict.isExternal() && ((DictionaryMetadataImpl) dict).isSrcExtTable()) {
          dictComingFromExtTable
              .add(ModuleUtils.prepareQualifiedName(getModuleName(), dict.getDictName()));
        }
      }
    }
    return dictComingFromExtTable.toArray(new String[0]);
  }

  /**
   * Returns the list of all the output alias names defined in the module.
   * 
   * @return the list of all the output alias names defined in the module
   */
  public List<String> getOutputAliasNames() {
    ArrayList<String> outputAliasNames = new ArrayList<String>();
    if (null != views.view) {
      for (ViewMetadata view : views.view) {
        if (view.isOutputView()) {
          String outputAlias = view.getOutputAlias();
          if (null != outputAlias)
            outputAliasNames.add(outputAlias);
        }
      }
    }
    return outputAliasNames;
  }

  /**
   * Returns an empty module metadata instance. This method is just for internal use, hence not part
   * of public {@link ModuleMetadata} interface.
   * 
   * @return an empty module metadata instance
   */
  public static ModuleMetadataImpl createEmptyMDInstance() {
    ModuleMetadataImpl emptyMD = new ModuleMetadataImpl();

    emptyMD.setDictionaries(new Dictionaries());
    emptyMD.setTables(new Tables());
    emptyMD.setViews(new Views());
    emptyMD.setFunctions(new Functions());

    return emptyMD;
  }

  private String getViewModuleName(ViewMetadata vmd) {
    if (null != vmd.getModuleName())
      return vmd.getModuleName();
    else
      return this.getModuleName();
  }

  /**
   * JAXB class for the &lt;requiredModules&gt; element under &lt;module-metadata&gt;
   */
  @XmlAccessorType(XmlAccessType.FIELD)
  @XmlType(name = "", propOrder = {"item"})
  public static class RequiredModules implements Serializable {

    private static final long serialVersionUID = -5599059306746678221L;

    protected List<String> item;

    public RequiredModules() {
      this.item = new ArrayList<String>();
    }

    public RequiredModules(List<String> list) {
      this.item = list;
    }

    /**
     * @return the list of required modules
     */
    public List<String> getItem() {
      return item;
    }

    /**
     * @param list the list of required modules
     */
    public void setItem(List<String> list) {
      this.item = list;
    }

    @Override
    public boolean equals(Object obj) {
      if (false == obj instanceof RequiredModules)
        return false;

      if (null == obj)
        return false;
      RequiredModules other = (RequiredModules) obj;

      // item
      if (false == ObjectComparator.equals(this.item, other.item)) {
        throw new ModuleMetadataMismatchException(null, "requiredModules",
            String.valueOf(this.item), String.valueOf(other.item));
      }

      // return true if all tests passes
      return true;
    }

    @Override
    public int hashCode() {
      throw new FatalInternalError("Hashcode not implemented for class %s.",
          this.getClass().getSimpleName());
    }

  }

  @Override
  public boolean equals(Object obj) {

    if (null == obj)
      return false;

    if (false == obj instanceof ModuleMetadataImpl)
      return false;

    ModuleMetadataImpl other = (ModuleMetadataImpl) obj;

    // dependent modules
    if (false == ObjectComparator.equals(this.getDependentModules(), other.getDependentModules())) {
      throw new ModuleMetadataMismatchException(moduleName, "requiredModules",
          String.valueOf(this.getDependentModules()), String.valueOf(other.getDependentModules()));
    }

    // comment
    if (false == ObjectComparator.equals(this.getComment(), other.getComment())) {
      throw new ModuleMetadataMismatchException(moduleName, "comment", this.getComment(),
          other.getComment());
    }

    try {
      // compare dictionaries. Will throw ModuleMetadataMismatchException if they do not match
      ObjectComparator.equals(this.dictionaries, other.dictionaries);

      // compare functions. Will throw ModuleMetadataMismatchException if they do not match
      ObjectComparator.equals(this.functions, other.functions);

      // compare tables. Will throw ModuleMetadataMismatchException if they do not match
      ObjectComparator.equals(this.tables, other.tables);

      // compare views. Will throw ModuleMetadataMismatchException if they do not match
      ObjectComparator.equals(this.views, other.views);
    } catch (ModuleMetadataMismatchException e) {
      // set the module name before re-throw, as the exception arising from sub components (like
      // dictionaries, functions
      // etc) would not contain module name info
      e.moduleName = this.moduleName;
      throw e;
    }

    // return true, if all checks have passed
    return true;
  }

  @Override
  public int hashCode() {
    throw new FatalInternalError("Hashcode not implemented for class %s.",
        this.getClass().getSimpleName());
  }

  @Override
  public String toString() {
    return String.format(
        "moduleName: %s, compilationTime: %s, hostName: %s, userName: %s, productVersion: %s, tokenizerType: %s\n views: %s\n dictionaries: %s\n tables: %s\n functions: %s\n requiredModules: %s\n dependsOn: %s",
        moduleName, compilationTime, hostName, userName, productVersion, tokenizerType,
        views.toString(), dictionaries.toString(), tables.toString(), functions.toString(),
        requiredModules.toString(), dependsOn);
  }
}

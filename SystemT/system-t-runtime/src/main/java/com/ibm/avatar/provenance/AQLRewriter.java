/*******************************************************************************
 * Copyright IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 *******************************************************************************/
package com.ibm.avatar.provenance;

import java.util.ArrayList;

import com.ibm.avatar.aql.ConsolidateClauseNode;
import com.ibm.avatar.aql.CreateViewNode;
import com.ibm.avatar.aql.ExtractNode;
import com.ibm.avatar.aql.ExtractPatternNode;
import com.ibm.avatar.aql.FromListItemNode;
import com.ibm.avatar.aql.FromListItemTableFuncNode;
import com.ibm.avatar.aql.FromListNode;
import com.ibm.avatar.aql.GroupByClauseNode;
import com.ibm.avatar.aql.HavingClauseNode;
import com.ibm.avatar.aql.MinusNode;
import com.ibm.avatar.aql.OrderByClauseNode;
import com.ibm.avatar.aql.ParseException;
import com.ibm.avatar.aql.PredicateNode;
import com.ibm.avatar.aql.RValueNode;
import com.ibm.avatar.aql.ScalarFnCallNode;
import com.ibm.avatar.aql.SelectListItemNode;
import com.ibm.avatar.aql.SelectListNode;
import com.ibm.avatar.aql.SelectNode;
import com.ibm.avatar.aql.TableFnCallNode;
import com.ibm.avatar.aql.UnionAllNode;
import com.ibm.avatar.aql.ViewBodyNode;
import com.ibm.avatar.aql.WhereClauseNode;
import com.ibm.avatar.aql.catalog.Catalog;

/**
 * Version of {@link com.ibm.avatar.aql.planner.AQLRewriter} customized for performing provenance
 * rewrite.
 */
public class AQLRewriter {

  /** Callback for rewriting various parts of the original query. */
  protected static abstract class rewriter<T> {
    abstract T rewrite(T orig) throws ParseException;

    /** Name of the view currently being rewritten (for debugging) */
    protected String curViewName;

    /** module name of the curViewName */
    protected String curModuleName = "";

    /** Catalog containing the original version of the views (not the rewritten version). */
    protected Catalog catalog;

    /**
     * Set of rewritten views required to collect views generated during the rewrite (including the
     * rewritten version of original views, as well as new auxiliary views generated by the
     * rewrite). The current provenance rewrite stores rewritten views in a list. At some point, we
     * should modify the provenance rewrite to build a fresh new catalog and hold all rewritten
     * views in that catalog, but that requires some careful testing.
     */
    protected ArrayList<CreateViewNode> rewrittenViews;
  }

  /**
   * Callback for rewriting select and extract statements at the same time.
   */
  protected static abstract class selectExtractRewriter extends rewriter<ViewBodyNode> {
  }

  /**
   * Callback for rewriting the FROM list.
   */
  protected static abstract class fromItemRewriter extends rewriter<FromListItemNode> {
  }

  /**
   * Callback for rewriting scalar function calls.
   */
  protected static abstract class funcRewriter extends rewriter<ScalarFnCallNode> {
  }

  /**
   * A generic query rewrite; replaces every select and extract statement with a rewritten version.
   * 
   * @param callback callback that does the actual rewriting
   * @param root root node of the part of the parse tree to rewrite
   * @param moduleName name of the module the view belongs to
   * @param viewName name of the enclosing view
   * @return a rewritten version of the tree rooted at root
   */
  protected static ViewBodyNode rewriteSelectsAndExtracts(selectExtractRewriter callback,
      ViewBodyNode root, String moduleName, String viewName) throws ParseException {

    int suffix;
    String suffixViewName;
    callback.curModuleName = moduleName;
    callback.curViewName = viewName;

    if (root instanceof SelectNode) {
      SelectNode stmt = (SelectNode) root;
      return callback.rewrite(stmt);
    } else if (root instanceof UnionAllNode) {

      // UNION ALL of multiple select statements
      UnionAllNode union = (UnionAllNode) root;

      for (int s = 0; s < union.getNumStmts(); s++) {
        ViewBodyNode stmt = union.getStmt(s);

        // Assign different suffixes to avoid collision of names on
        // the new created internal views we create
        suffix = s + 1;
        suffixViewName = String.format("%s_%s", viewName, suffix);

        union.setStmt(s, rewriteSelectsAndExtracts(callback, stmt, moduleName, suffixViewName));
      }

      return union;

    } else if (root instanceof MinusNode) {

      // Set difference over select statements
      MinusNode minus = (MinusNode) root;

      // Assign different suffixes to avoid collision of names on
      // the new created internal views we create
      suffixViewName = String.format("%s_%s", viewName, 1);
      minus.setFirstStmt(
          rewriteSelectsAndExtracts(callback, minus.getFirstStmt(), moduleName, suffixViewName));

      suffixViewName = String.format("%s_%s", viewName, 1);
      minus.setSecondStmt(
          rewriteSelectsAndExtracts(callback, minus.getSecondStmt(), moduleName, suffixViewName));

      return minus;

    } else if (root instanceof ExtractNode) {

      return callback.rewrite((ExtractNode) root);

    } else if (root instanceof ExtractPatternNode) {

      return callback.rewrite((ExtractPatternNode) root);

    } else {
      throw new RuntimeException("Don't know how to rewrite " + root);
    }
  }

  /**
   * In-place rewrite of scalar function calls. Assumes that all subqueries have been unnested.
   * 
   * @param callback callback function that does the work of replacing function calls
   */
  protected static void rewriteScalarFuncs(final funcRewriter callback, CreateViewNode cvn)
      throws ParseException {

    // Create a visitor that will visit each select or extract node in turn.
    class cb extends selectExtractRewriter {

      @Override
      ViewBodyNode rewrite(ViewBodyNode orig) throws ParseException {

        // SelectList, FromList and Consolidate clause are common in both Select and Extract
        // statements
        SelectListNode selectList = null;
        FromListNode fromList = null;
        ConsolidateClauseNode consolidateClause = null;

        if (orig instanceof SelectNode) {
          // SELECT statement; look in the select,where and consolidate clauses
          // for function calls.
          SelectNode select = (SelectNode) orig;

          // Since select list and consolidate clause are common to
          // both select and extract stmt, rewrite for them is
          // after the if-else
          selectList = select.getSelectList();
          consolidateClause = select.getConsolidateClause();
          fromList = select.getFromList();

          // Where clause is currently only found on select stmts
          WhereClauseNode whereClause = select.getWhereClause();
          if (null != whereClause) {
            for (int i = 0; i < whereClause.size(); i++) {
              PredicateNode pred = whereClause.getPred(i);
              ScalarFnCallNode newFunc = rewriteSingleFunc(pred.getFunc(), callback);
              pred.replaceFunc(newFunc);
            }
          }

          // Group by clause is currently only found on select stmts
          GroupByClauseNode groupByClause = select.getGroupByClause();
          if (null != groupByClause) {
            for (int i = 0; i < groupByClause.size(); i++) {
              RValueNode value = groupByClause.getValue(i);
              if (value instanceof ScalarFnCallNode) {
                ScalarFnCallNode newVal = rewriteSingleFunc((ScalarFnCallNode) value, callback);
                groupByClause.replaceValue(i, newVal);
              }
            }
          }

          // Order by clause is currently only found on select stmts
          OrderByClauseNode orderByClause = select.getOrderByClause();
          if (null != orderByClause) {
            for (int i = 0; i < orderByClause.size(); i++) {
              RValueNode value = orderByClause.getValue(i);
              if (value instanceof ScalarFnCallNode) {
                ScalarFnCallNode newVal = rewriteSingleFunc((ScalarFnCallNode) value, callback);
                orderByClause.replaceValue(i, newVal);
              }
            }
          }

        } else if (orig instanceof ExtractNode || orig instanceof ExtractPatternNode) {

          HavingClauseNode havingClause = null;
          FromListItemNode target = null;

          if (orig instanceof ExtractNode) {
            // EXTRACT statement; check the having clause,consolidate clause and select list for
            // function
            // calls
            ExtractNode extract = (ExtractNode) orig;
            selectList = extract.getExtractList().getSelectList();
            consolidateClause = extract.getConsolidateClause();
            havingClause = extract.getHavingClause();
            target = extract.getTarget();
          } else {
            ExtractPatternNode pattern = (ExtractPatternNode) orig;
            selectList = pattern.getSelectList();
            consolidateClause = pattern.getConsolidateClause();
            havingClause = pattern.getHavingClause();
            fromList = pattern.getFromList();
          }

          // Apply the callback to the target in the FROm clause
          if (null != target) {
            if (target instanceof FromListItemTableFuncNode) {
              TableFnCallNode tabFn = ((FromListItemTableFuncNode) target).getTabfunc();

              for (int i = 0; i < tabFn.getArgs().size(); i++) {
                RValueNode value = tabFn.getArgs().get(i);
                if (value instanceof ScalarFnCallNode) {
                  ScalarFnCallNode newVal = rewriteSingleFunc((ScalarFnCallNode) value, callback);
                  tabFn.getArgs().set(i, newVal);
                }
              }
            }
          }

          // Apply the callback to the HAVING clause
          if (null != havingClause) {
            for (int i = 0; i < havingClause.size(); i++) {
              PredicateNode pred = havingClause.getPred(i);
              ScalarFnCallNode newFunc = rewriteSingleFunc(pred.getFunc(), callback);
              pred.replaceFunc(newFunc);
            }
          }

        }

        // Apply callback to function calls in select list
        if (null != selectList) {
          for (int i = 0; i < selectList.size(); i++) {
            SelectListItemNode item = selectList.get(i);
            // Get the origValue, not the value, since the latter becomes s wrapped into a function
            // call that
            // doesn't print itself properly back to AQL.
            RValueNode value = item.getOrigValue();
            if (value instanceof ScalarFnCallNode) {
              ScalarFnCallNode newVal = rewriteSingleFunc((ScalarFnCallNode) value, callback);
              item.replaceValue(newVal);
            }
          }
        }

        // Apply the callback to the FROM list
        if (null != fromList) {
          for (FromListItemNode fromNode : fromList.getItems()) {
            if (fromNode instanceof FromListItemTableFuncNode) {
              TableFnCallNode tabFn = ((FromListItemTableFuncNode) fromNode).getTabfunc();

              for (int i = 0; i < tabFn.getArgs().size(); i++) {
                RValueNode value = tabFn.getArgs().get(i);
                if (value instanceof ScalarFnCallNode) {
                  ScalarFnCallNode newVal = rewriteSingleFunc((ScalarFnCallNode) value, callback);
                  tabFn.getArgs().set(i, newVal);
                }
              }
            }
          }
        }

        // Apply callback to function call in consolidate clause
        if (null != consolidateClause) {
          RValueNode target = consolidateClause.getTarget();
          if (target instanceof ScalarFnCallNode) {
            ScalarFnCallNode newTarget = rewriteSingleFunc((ScalarFnCallNode) target, callback);
            consolidateClause.replaceTarget(newTarget);
          }

          // If the consolidate clause has a "with priority from" clause,
          // rewrite the target of the "with priority from" clause.
          RValueNode priorityTarget = consolidateClause.getPriorityTarget();
          if (priorityTarget instanceof ScalarFnCallNode) {
            ScalarFnCallNode newPriorityTarget =
                rewriteSingleFunc((ScalarFnCallNode) priorityTarget, callback);
            consolidateClause.replacePriorityTarget(newPriorityTarget);
          }
        }

        // All of our changes happened in place, so just return the
        // original top-level node.
        return orig;
      }

    }

    // Pass the visitor into the function that will iterate over all the
    // select statements in the indicated view.
    cvn.setBody(rewriteSelectsAndExtracts(new cb(), cvn.getBody(), cvn.getModuleName(),
        cvn.getUnqualifiedName()));
  }

  /**
   * Subroutine of {@link #rewriteScalarFuncs(funcRewriter, CreateViewNode)}. Recursively rewrites
   * the children of a function call, then does the call itself.
   * 
   * @throws ParseException
   */
  private static ScalarFnCallNode rewriteSingleFunc(ScalarFnCallNode input, funcRewriter callback)
      throws ParseException {

    // First, rewrite the children of the function call.
    ArrayList<RValueNode> args = input.getArgs();
    for (int i = 0; i < args.size(); i++) {
      RValueNode orig = args.get(i);

      if (orig instanceof ScalarFnCallNode) {
        ScalarFnCallNode origFunc = (ScalarFnCallNode) orig;
        ScalarFnCallNode newFunc = rewriteSingleFunc(origFunc, callback);

        // Assume we can replace in place.
        args.set(i, newFunc);
      }
    }

    // Now we can do the function call itself.
    return callback.rewrite(input);
  }

  /**
   * In-place rewrite of table functions.
   */
  protected static void rewriteTabFuncs(fromItemRewriter callback, CreateViewNode cvn)
      throws ParseException {
    final fromItemRewriter tabFuncCB = callback;

    // Create a visitor that will modify each node in turn.
    class cb extends selectExtractRewriter {

      @Override
      ViewBodyNode rewrite(ViewBodyNode orig) throws ParseException {

        if (orig instanceof SelectNode || orig instanceof ExtractPatternNode) {

          FromListNode fromList = orig instanceof SelectNode ? ((SelectNode) orig).getFromList()
              : ((ExtractPatternNode) orig).getFromList();

          for (int i = 0; i < fromList.size(); i++) {
            FromListItemNode origItem = fromList.get(i);

            if (origItem instanceof FromListItemTableFuncNode) {
              // Found a table function; rewrite it.
              tabFuncCB.curViewName = this.curViewName;
              tabFuncCB.curModuleName = this.curModuleName;
              FromListItemNode newItem = tabFuncCB.rewrite(origItem);
              fromList.set(i, newItem);
            }
          }
        } else if (orig instanceof ExtractNode) {
          FromListItemNode origItem = ((ExtractNode) orig).getTarget();

          if (origItem instanceof FromListItemTableFuncNode) {
            // Found a table function; rewrite it.
            tabFuncCB.curViewName = this.curViewName;
            tabFuncCB.curModuleName = this.curModuleName;
            FromListItemNode newItem = tabFuncCB.rewrite(origItem);
            ((ExtractNode) orig).setTarget(newItem);
          }
        }
        return orig;
      }
    }

    // Pass the visitor into the function that will iterate over all the
    // select statements in the indicated view.
    cvn.setBody(rewriteSelectsAndExtracts(new cb(), cvn.getBody(), cvn.getModuleName(),
        cvn.getUnqualifiedName()));
  }
}

/*******************************************************************************
 * Copyright IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 *******************************************************************************/
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
// Implementation, vJAXB 2.1.10 in
// JDK 6
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
// Any modifications to this file will be lost upon recompilation of the source schema.
// Generated on: 2012.06.19 at 04:26:09 PM IST
//

package com.ibm.avatar.aql.tam;

import java.util.ArrayList;
import java.util.List;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlType;

import com.ibm.avatar.algebra.datamodel.FieldType;
import com.ibm.avatar.algebra.datamodel.TupleSchema;
import com.ibm.avatar.api.Constants;
import com.ibm.avatar.api.exceptions.FatalInternalError;
import com.ibm.avatar.api.tam.ViewMetadata;
import com.ibm.avatar.aql.AQLParserBase;
import com.ibm.avatar.aql.ParseException;
import com.ibm.avatar.aql.Token;
import com.ibm.avatar.aql.doc.AQLDocComment;
import com.ibm.avatar.aql.planner.CostRecord;
import com.ibm.avatar.aql.planner.SimpleCostModel.SimpleCostRecord;
import com.ibm.avatar.aql.tam.SchemaType.Column;
import com.ibm.biginsights.textanalytics.util.ObjectComparator;

/**
 * JAXB class to represent the view metadata
 */
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "ViewMetadataImpl", namespace = "http://www.ibm.com/aql",
    propOrder = {"schema", "costRec", "comment"})
public class ViewMetadataImpl implements ViewMetadata {

  private static final long serialVersionUID = 4367819408934865557L;

  @XmlElement(required = true)
  protected SchemaType schema;
  @XmlElement(required = true)
  protected CostRecordType costRec;
  /**
   * The comment for this construct, with leading and trailing comment separators removed, and
   * leading asterisks on each line also removed.
   */
  @XmlElement
  protected CommentType comment;
  @XmlAttribute
  protected String viewName;
  @XmlAttribute
  protected Boolean exported;
  @XmlAttribute
  protected Boolean external;
  @XmlAttribute
  protected Boolean output;

  /**
   * Name of module to which {@link #viewName} belongs.
   */
  @XmlAttribute
  protected String moduleName;

  /**
   * Output alias name defined for the view via 'output view ...' statement alias clause.
   */
  @XmlAttribute
  protected String outputAlias;

  /**
   * external name of the view as define in 'create external view ...' statement's external_name
   * clause.
   */
  @XmlAttribute
  protected String externalName;

  /**
   * @return the costRec
   */
  public CostRecordType getCostRec() {
    return costRec;
  }

  /**
   * @param costRec the costRec to set
   */
  public void setCostRec(CostRecordType costRec) {
    this.costRec = costRec;
  }

  /**
   * Gets the value of the schema property.
   * 
   * @return possible object is {@link SchemaType }
   */
  public SchemaType getSchema() {
    return schema;
  }

  /**
   * Sets the value of the schema property.
   * 
   * @param value allowed object is {@link SchemaType }
   */
  public void setSchema(SchemaType value) {
    this.schema = value;
  }

  /**
   * Gets the value of the viewName property.
   * 
   * @return possible object is {@link String }
   */
  @Override
  public String getViewName() {
    return viewName;
  }

  /**
   * Sets the value of the viewName property.
   * 
   * @param value allowed object is {@link String }
   */
  public void setViewName(String value) {
    this.viewName = value;
  }

  /**
   * Gets the value of the comment property.
   * 
   * @return the comment
   */
  @Override
  public String getComment() {
    if (null == comment)
      return null;
    return comment.getText();
  }

  /**
   * Sets the value of the comment property.
   * 
   * @param value allowed object is {@link CommentType }
   */
  public void setComment(CommentType value) {
    this.comment = value;
  }

  /**
   * Gets the value of the exported property.
   * 
   * @return possible object is {@link Boolean }
   */
  public Boolean getExported() {
    return exported;
  }

  /**
   * Sets the value of the exported property.
   * 
   * @param value allowed object is {@link Boolean }
   */
  public void setExported(Boolean value) {
    this.exported = value;
  }

  /**
   * Gets the value of the external property.
   * 
   * @return possible object is {@link Boolean }
   */
  public Boolean getExternal() {
    return external;
  }

  /**
   * Sets the value of the external property.
   * 
   * @param value allowed object is {@link Boolean }
   */
  public void setExternal(Boolean value) {
    this.external = value;
  }

  /**
   * Gets the value of the output property.
   * 
   * @return possible object is {@link Boolean }
   */
  public Boolean getOutput() {
    return output;
  }

  /**
   * Sets the value of the output property.
   * 
   * @param value allowed object is {@link Boolean }
   */
  public void setOutput(Boolean value) {
    this.output = value;
  }

  @Override
  public boolean isOutputView() {
    return getOutput().booleanValue();
  }

  @Override
  public boolean isExported() {
    return getExported().booleanValue();
  }

  @Override
  public boolean isExternal() {
    return getExternal().booleanValue();
  }

  @Override
  public CostRecord getCostRecord() {
    SimpleCostRecord ret = new SimpleCostRecord();

    // for legacy TAMs, costRec might be null for certain types of views.
    if (costRec != null) {
      ret.numHashJoins = costRec.numHashJoins;
      ret.numJavaRegexes = costRec.numJavaRegexes;
      ret.numMergeJoins = costRec.numMergeJoins;
      ret.numMultiRegexes = costRec.numMultiRegexes;
      ret.numNLJoins = costRec.numNLJoins;
      ret.numSimpleRegexes = costRec.numSimpleRegexes;
    }
    return ret;
  }

  /**
   * Prepares metadata cost record by copying info from catalog cost record
   * 
   * @param rec the cost record from the catalog
   * @param viewName the view corresponding to the input cost record
   */
  public void setCostRecord(CostRecord rec, Token tok, String viewName) throws ParseException {

    if (rec == null) {
      throw AQLParserBase.makeException(
          String.format("No cost record information found for view %s.", viewName), tok);
    }

    if (rec instanceof SimpleCostRecord) {
      SimpleCostRecord cr = (SimpleCostRecord) rec;

      CostRecordType crt = new CostRecordType();
      crt.numHashJoins = cr.numHashJoins;
      crt.numJavaRegexes = cr.numJavaRegexes;
      crt.numMergeJoins = cr.numMergeJoins;
      crt.numMultiRegexes = cr.numMultiRegexes;
      crt.numNLJoins = cr.numNLJoins;
      crt.numSimpleRegexes = cr.numSimpleRegexes;

      setCostRec(crt);
    }
  }

  @Override
  public TupleSchema getViewSchema() {
    List<Column> fields = schema.column;
    String colNames[] = new String[fields.size()];
    FieldType colTypes[] = new FieldType[fields.size()];

    for (int i = 0; i < fields.size(); i++) {
      colNames[i] = fields.get(i).name;
      try {
        colTypes[i] = FieldType.stringToFieldType(fields.get(i).type);
      } catch (ParseException e) {
        // Calling code doesn't have a way to handle ParseException
        throw new FatalInternalError(e, "Error reading type for column %d of view %s from metadata"
            + " (serialized form of type is '%s')", i, viewName, fields.get(i).type);
      }
    }

    TupleSchema schema = new TupleSchema(colNames, colTypes);
    schema.setName(getViewName());

    // sort the doc schema for a consistent order
    if (getViewName().equals(Constants.DEFAULT_DOC_TYPE_NAME)) {
      schema = ModuleUtils.sortSchemaWithNonParameterizedTypes(schema);
    }

    return schema;
  }

  public void setSchema(TupleSchema viewSchema) {
    SchemaType schema = new SchemaType();
    schema.column = new ArrayList<SchemaType.Column>();

    String colNames[] = viewSchema.getFieldNames();
    FieldType colTypes[] = viewSchema.getFieldTypes();

    for (int i = 0; i < colNames.length; ++i) {
      Column col = new Column();
      col.name = colNames[i];
      col.type = colTypes[i].getTypeName();
      schema.column.add(col);
    }

    setSchema(schema);

  }

  /**
   * Set the AQL doc comment string associated with this view. If the input comment exists, that is,
   * the AQL file where this statement was defined did contain an AQL doc comment for this
   * statement, we set the comment to be a lightly cleaned up version of the original comment text,
   * as provided by {@link AQLDocComment#getCleanedText()}.
   * 
   * @param comment AQL doc comment associated with this statement in the AQL code
   */
  public void setComment(AQLDocComment comment) {
    if (null != comment) {
      this.comment = new CommentType();
      this.comment.setText(comment.getCleanText());
    }
  }

  /**
   * Set the comment with an individual string. Use this method when the comment is a substring of
   * an AQL doc comment, as for example in the case of the document comment which comes from the
   * module.info file, or the comment for detag and detag auxiliary views.
   * 
   * @param comment
   */
  public void setComment(String comment) {
    if (null != comment) {
      this.comment = new CommentType();
      this.comment.setText(comment);
    }
  }

  @Override
  public String getModuleName() {
    return moduleName;
  }

  public void setModuleName(String moduleName) {
    this.moduleName = moduleName;
  }

  @Override
  public String getOutputAlias() {
    return outputAlias;
  }

  public void setOutputAlias(String outputAlias) {
    this.outputAlias = outputAlias;
  }

  @Override
  public String getExternalName() {
    return externalName;
  }

  public void setExternalName(String externalName) {
    this.externalName = externalName;
  }

  @Override
  public boolean equals(Object obj) {
    if (obj == null) {
      return false;
    }
    if (false == obj instanceof ViewMetadataImpl)
      return false;

    ViewMetadataImpl other = (ViewMetadataImpl) obj;

    // use null for <code>moduleName</code> in calls to ModuleMetadataMismatchException()
    // constructor below, as we do
    // not know the module name at this point. ModuleMetadataImpl.equals() would set the
    // <code>moduleName</code> before
    // re-throwing this exception to the consumers.

    // comment
    if (false == ObjectComparator.equals(this.getComment(), other.getComment()))
      throw new ModuleMetadataMismatchException(null, "view.comment",
          String.valueOf(this.getComment()), String.valueOf(other.getComment()));

    // costRec
    if (false == ObjectComparator.equals(this.costRec, other.costRec))
      throw new ModuleMetadataMismatchException(null, "view.costRec", String.valueOf(this.costRec),
          String.valueOf(other.costRec));

    // exported
    if (false == ObjectComparator.equals(this.exported, other.exported))
      throw new ModuleMetadataMismatchException(null, "view.exported",
          String.valueOf(this.exported), String.valueOf(other.exported));

    // external
    if (false == ObjectComparator.equals(this.external, other.external))
      throw new ModuleMetadataMismatchException(null, "view.external",
          String.valueOf(this.external), String.valueOf(other.external));

    // external
    if (false == ObjectComparator.equals(this.external, other.external))
      throw new ModuleMetadataMismatchException(null, "view.external",
          String.valueOf(this.external), String.valueOf(other.external));

    // externalName
    if (false == ObjectComparator.equals(this.externalName, other.externalName))
      throw new ModuleMetadataMismatchException(null, "view.externalName",
          String.valueOf(this.externalName), String.valueOf(other.externalName));

    // moduleName
    if (false == ObjectComparator.equals(this.moduleName, other.moduleName))
      throw new ModuleMetadataMismatchException(null, "view.moduleName",
          String.valueOf(this.moduleName), String.valueOf(other.moduleName));

    // output
    if (false == ObjectComparator.equals(this.output, other.output))
      throw new ModuleMetadataMismatchException(null, "view.output", String.valueOf(this.output),
          String.valueOf(other.output));

    // outputAlias
    if (false == ObjectComparator.equals(this.outputAlias, other.outputAlias))
      throw new ModuleMetadataMismatchException(null, "view.outputAlias",
          String.valueOf(this.outputAlias), String.valueOf(other.outputAlias));

    // schema
    if (false == ObjectComparator.equals(this.schema, other.schema))
      throw new ModuleMetadataMismatchException(null, "view.schema", String.valueOf(this.schema),
          String.valueOf(other.schema));

    // viewName
    if (false == ObjectComparator.equals(this.viewName, other.viewName))
      throw new ModuleMetadataMismatchException(null, "view.viewName",
          String.valueOf(this.viewName), String.valueOf(other.viewName));

    // return true, if all tests pass
    return true;
  }

  @Override
  public int hashCode() {
    throw new FatalInternalError("Hashcode not implemented for class %s.",
        this.getClass().getSimpleName());
  }

  @Override
  public String toString() {
    return String.format(
        "moduleName: %s, viewName: %s, output: %s, outputAlias: %s, exported: %s, external: %s, externalName: %s",
        moduleName, viewName, output, outputAlias, exported, external, externalName);
  }
}

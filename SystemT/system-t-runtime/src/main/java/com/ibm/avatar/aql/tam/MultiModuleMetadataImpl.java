/*******************************************************************************
 * Copyright IBM
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 *******************************************************************************/
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference
// Implementation, vJAXB 2.1.10 in
// JDK 6
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a>
// Any modifications to this file will be lost upon recompilation of the source schema.
// Generated on: 2012.06.19 at 04:26:09 PM IST
//

package com.ibm.avatar.aql.tam;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.regex.Pattern;

import com.ibm.avatar.algebra.datamodel.Pair;
import com.ibm.avatar.algebra.datamodel.TupleSchema;
import com.ibm.avatar.algebra.util.string.StringUtils;
import com.ibm.avatar.api.Constants;
import com.ibm.avatar.api.exceptions.DocSchemaMismatchException;
import com.ibm.avatar.api.exceptions.FatalInternalError;
import com.ibm.avatar.api.exceptions.IncompatibleTokenizerConfigException;
import com.ibm.avatar.api.exceptions.InvalidModuleElementException;
import com.ibm.avatar.api.exceptions.ModuleLoadException;
import com.ibm.avatar.api.tam.DictionaryMetadata;
import com.ibm.avatar.api.tam.FunctionMetadata;
import com.ibm.avatar.api.tam.ModuleMetadata;
import com.ibm.avatar.api.tam.ModuleMetadata.ElementType;
import com.ibm.avatar.api.tam.ModuleMetadataFactory;
import com.ibm.avatar.api.tam.MultiModuleMetadata;
import com.ibm.avatar.api.tam.TableMetadata;
import com.ibm.avatar.api.tam.ViewMetadata;
import com.ibm.biginsights.textanalytics.util.ObjectComparator;

/**
 * This class provides APIs to retrieve metadata of various AQL elements from the loaded
 * {@link MultiModuleMetadataImpl} object. An instance of this type can be obtained by invoking one
 * of the {@link getAllMetadata} APIs in {@link ModuleMetadataFactory} class. The class is very
 * similar to {@link ModuleMetadata}, except that each {@link MultiModuleMetadataImpl} object
 * represents metadata associated with a set of modules. This module set is guaranteed to be
 * complete, containing every module that is referenced by the modules in the input module list
 * passed to the constructor.
 * 
 * @see ModuleMetadata
 */
public class MultiModuleMetadataImpl implements MultiModuleMetadata {

  /* the names of the modules in this module set */
  protected TreeSet<String> moduleNames;

  /** all the metadata for the modules in this module set */
  protected List<ModuleMetadataImpl> modules;

  /**
   * PROPERTY GETTER/SETTER METHODS
   */

  /**
   * Return the names of the modules in the module set represented by this metadata. Includes all
   * dependencies (transitive or direct).
   * 
   * @return the names of the modules in this module set
   */
  @Override
  public String[] getModuleNames() {
    return (String[]) moduleNames.toArray(new String[moduleNames.size()]);
  }

  /**
   * Sets the value of the moduleNames property.
   * 
   * @param value allowed object is {@link String }
   */
  public void setModuleNames(TreeSet<String> list) {
    this.moduleNames = list;
  }

  /**
   * Gets the value of the modules property.
   * 
   * @return possible object is {@link MultiModuleMetadataImpl.Modules }
   */
  public List<ModuleMetadataImpl> getModules() {
    return modules;
  }

  /**
   * Sets the value of the modules property.
   * 
   * @param value allowed object is {@link MultiModuleMetadataImpl.Modules }
   */
  public void setModules(List<ModuleMetadataImpl> value) {
    this.modules = value;
  }

  /**
   * API METHODS
   */

  /**
   * Provides the schema of the input document to the extractor formed by the unionization of all
   * modules within the module set.
   * 
   * @return input document schema to the union of all modules within the module set
   */
  @Override
  public TupleSchema getDocSchema() {
    Map<String, TupleSchema> moduleSchemas = new HashMap<String, TupleSchema>();

    if (modules != null) {
      for (ModuleMetadata moduleMetadata : modules) {
        moduleSchemas.put(moduleMetadata.getModuleName(), moduleMetadata.getDocSchema());
      }
    }

    return ModuleUtils.computeMergedSchema(moduleSchemas);
  }

  /**
   * Returns metadata for a given module name.
   * 
   * @param moduleName name of the module whose metadata is to be retrieved
   * @return module metadata object; <code>null</code>, if metadata not found for the given module
   *         name
   */
  @Override
  public ModuleMetadata getModuleMetadata(String moduleName) {
    if (moduleName == null) {
      return null;
    }

    if (modules != null) {
      for (ModuleMetadata moduleMetadata : modules) {
        if (moduleName.equals(moduleMetadata.getModuleName())) {
          return moduleMetadata;
        }
      }
    }

    return null;
  }

  /**
   * Returns view metadata of a given view name.
   * 
   * @param viewName this name can be one of the following: an output alias, an external name (in
   *        case of external view), the fully qualified name for modular AQLs, an unqualified view
   *        name inside a genericModule(module generate for non-modular AQL code), or the view
   *        Document
   * @return view metadata object; <code>null</code>, if metadata not found for the given view name
   * @throws RuntimeException if multiple matches are found in the metadata for the given view name
   */
  @Override
  public ViewMetadata getViewMetadata(String viewName) {
    return (ViewMetadata) getElementMetadata(ElementType.VIEW, viewName);
  }

  /**
   * Returns metadata for a given dictionary name.
   * 
   * @param dictName qualified dictionary name, if modular AQL; unqualified otherwise
   * @return dictionary metadata object;<code>null</code>, if metadata not found for the given
   *         dictionary name
   */
  @Override
  public DictionaryMetadata getDictionaryMetadata(String dictName) {
    return (DictionaryMetadata) getElementMetadata(ElementType.DICTIONARY, dictName);
  }

  /**
   * Returns metadata for a given table name.
   * 
   * @param tableName qualified table name, if modular AQL; unqualified otherwise
   * @return table metadata object; <code>null</code>, if metadata not found for the given table
   *         name
   */
  @Override
  public TableMetadata getTableMetadata(String tableName) {
    return (TableMetadata) getElementMetadata(ElementType.TABLE, tableName);
  }

  /**
   * Returns metadata for a given function name.
   * 
   * @param functionName qualified function name, if modular AQL; unqualified otherwise
   * @return function metadata object; <code>null</code>, if metadata not found for the given
   *         function name
   */
  @Override
  public FunctionMetadata getFunctionMetadata(String functionName) {
    return (FunctionMetadata) getElementMetadata(ElementType.FUNCTION, functionName);
  }

  /**
   * Generic helper function to loop through all the modules in the module set and return the name
   * of the module containing the metadata, or an exception if there are multiple modules that are
   * valid.
   * 
   * @param type Type of the element whose metadata is looked up
   * @param elementName qualified name of the element, in modular AQL; unqualified, otherwise
   */
  private Object getElementMetadata(ElementType type, String elementName) {
    if (elementName == null) {
      return null;
    }

    // fetches the module name part of the element name. For genericModule, it returns ""
    String elemModuleName = ModuleUtils.getModuleName(elementName);

    Object metadata = null;

    if (modules != null) {

      // loop through all modules to find it
      for (ModuleMetadata moduleMetadata : modules) {

        // skip the loop if the current metadata's moduleName does not match elemModuleName
        // SPECIAL CASE: empty elemModuleName could mean genericModule (or) output view alias. So,
        // do NOT skip the loop
        // when empty module name is encountered
        if (false == elemModuleName.equals(moduleMetadata.getModuleName())
            && (false == StringUtils.isNullOrWhiteSpace(elemModuleName))) {
          continue;
        }

        switch (type) {
          case VIEW: {
            metadata = moduleMetadata.getViewMetadata(elementName);
            break;
          }
          case TABLE: {
            metadata = moduleMetadata.getTableMetadata(elementName);
            break;
          }
          case DICTIONARY: {
            metadata = moduleMetadata.getDictionaryMetadata(elementName);
            break;
          }
          case FUNCTION: {
            metadata = moduleMetadata.getFunctionMetadata(elementName);
            break;
          }
          default:
            throw new FatalInternalError(
                "getElementMetadata was called with illegal element type '%s'", type.getText());
        }

        // metadata found, no need to loop further
        if (metadata != null)
          break;
      }
    }

    // may be null, if metadata of given element is not found
    return metadata;
  }

  /**
   * Retrieve the text of the AQL doc comment associated with the given element of the given type.
   * 
   * @param type type of element
   * @param name qualified name of the element. For elements of type {@link ElementType#VIEW},this
   *        name be either be an output alias, fully qualified name,external name (in case of
   *        external view), or unqualified name for view inside a genericModule(module generated for
   *        non-modular AQL)
   * @return string contains the AQL doc comment associated for given element name
   * @throws InvalidModuleElementException if an element of the given type with the given name does
   *         not exist
   */
  @Override
  public String getComment(ElementType type, String name) throws InvalidModuleElementException {
    switch (type) {
      case VIEW: {
        ViewMetadata m = getViewMetadata(name);
        if (null == m)
          throw new InvalidModuleElementException(type, name);
        return m.getComment();
      }
      case TABLE: {
        TableMetadata m = getTableMetadata(name);
        if (null == m)
          throw new InvalidModuleElementException(type, name);
        return m.getComment();
      }
      case DICTIONARY: {
        DictionaryMetadata m = getDictionaryMetadata(name);
        if (null == m)
          throw new InvalidModuleElementException(type, name);
        return m.getComment();
      }
      case FUNCTION: {
        FunctionMetadata m = getFunctionMetadata(name);
        if (null == m)
          throw new InvalidModuleElementException(type, name);
        return m.getComment();
      }
      case MODULE: {
        ModuleMetadata m = getModuleMetadata(name);
        if (null == m)
          throw new InvalidModuleElementException(type, name);
        return m.getComment();
      }
      default: {
        throw new InvalidModuleElementException(type, name);
      }

    }
  }

  /**
   * Returns a list of names of the views marked as output view through the <code>output view</code>
   * statement. Names returned are either output view aliases created through
   * <code>output view</code> statement's 'as' clause, a view name qualified by containing module
   * name if alias is not declared, or an unqualified view name for genericModule (module compiled
   * from non-modular AQLs).
   * 
   * @return an array of output view names
   */
  @Override
  public String[] getOutputViews() {
    ArrayList<String> outputViews = new ArrayList<String>();

    if (modules != null) {
      for (ModuleMetadata moduleMetadata : modules) {
        String[] moduleOutputs = moduleMetadata.getOutputViews();

        // the output views are guaranteed not to conflict; checked during construction
        for (String moduleOutput : moduleOutputs) {
          outputViews.add(moduleOutput);
        }
      }
    }
    return outputViews.toArray(new String[0]);
  }

  /**
   * Returns list of all external view name pairs within the module set, where the first element of
   * the pair is the view name as declared in an AQL <code>create external view</code> statement.
   * For modular AQL, the view name returned will be qualified with containing module name; the
   * second argument is the external name as declared in an AQL <code>create external view</code>
   * statement's <code>external_name</code> clause.
   * 
   * @return list of external view name pairs
   */
  @Override
  public List<Pair<String, String>> getExternalViews() {
    ArrayList<Pair<String, String>> extViews = new ArrayList<Pair<String, String>>();

    if (modules != null) {
      for (ModuleMetadata moduleMetadata : modules) {
        List<Pair<String, String>> moduleExternalViews = moduleMetadata.getExternalViews();

        // the external views are guaranteed not to conflict; checked during construction
        for (Pair<String, String> moduleExternalView : moduleExternalViews) {
          extViews.add(moduleExternalView);
        }
      }
    }
    return extViews;
  }

  /**
   * Returns a list of qualified names of all views marked as exported via <code>export view</code>
   * statements within the module set.
   * 
   * @return a list of qualified names of all views marked as exported within the module set
   */
  @Override
  public String[] getExportedViews() {
    ArrayList<String> exportedViews = new ArrayList<String>();

    if (modules != null) {
      for (ModuleMetadata moduleMetadata : modules) {
        String[] moduleExportedViews = moduleMetadata.getExportedViews();

        // the external views are guaranteed not to conflict; checked during construction
        for (String moduleExternalView : moduleExportedViews) {
          exportedViews.add(moduleExternalView);
        }
      }
    }
    return exportedViews.toArray(new String[0]);
  }

  /**
   * Returns the list of qualified names for all external tables declared through the
   * <code>create external table</code> statement within the module set.
   * 
   * @return an array of all qualified names for declared external tables within the module set
   */
  @Override
  public String[] getExternalTables() {
    ArrayList<String> extTables = new ArrayList<String>();

    if (modules != null) {
      for (ModuleMetadata moduleMetadata : modules) {
        String[] moduleExternalTables = moduleMetadata.getExternalTables();

        // the external views are guaranteed not to conflict; checked during construction
        for (String moduleExternalTable : moduleExternalTables) {
          extTables.add(moduleExternalTable);
        }
      }
    }

    return extTables.toArray(new String[0]);
  }

  /**
   * Returns the qualified names of all tables marked as exported via the <code>export table</code>
   * statement within the module set.
   * 
   * @return an array of all qualified table names as exported within the module set
   */
  @Override
  public String[] getExportedTables() {
    ArrayList<String> expTables = new ArrayList<String>();
    if (modules != null) {
      for (ModuleMetadata moduleMetadata : modules) {
        String[] moduleExportedTables = moduleMetadata.getExportedTables();

        // the external views are guaranteed not to conflict; checked during construction
        for (String moduleExportedTable : moduleExportedTables) {
          expTables.add(moduleExportedTable);
        }
      }
    }
    return expTables.toArray(new String[0]);
  }

  /**
   * Returns a list of qualified names of the external dictionaries declared through the
   * <code>create external dictionary</code> statement.
   * 
   * @return an array of the qualified names of the declared external dictionary
   */
  @Override
  public String[] getExternalDictionaries() {
    ArrayList<String> extDicts = new ArrayList<String>();
    if (modules != null) {
      for (ModuleMetadata moduleMetadata : modules) {
        String[] moduleExternalDicts = moduleMetadata.getExternalDictionaries();

        // the external views are guaranteed not to conflict; checked during construction
        for (String moduleExternalDict : moduleExternalDicts) {
          extDicts.add(moduleExternalDict);
        }
      }
    }

    return extDicts.toArray(new String[0]);
  }

  /**
   * Returns a list of qualified names of dictionaries marked as exported through the
   * <code>export dictionary</code> statement.
   * 
   * @return list of qualified names of dictionaries marked as exported in the module
   */
  @Override
  public String[] getExportedDictionaries() {
    ArrayList<String> expDicts = new ArrayList<String>();
    if (modules != null) {
      for (ModuleMetadata moduleMetadata : modules) {
        String[] moduleExportedDicts = moduleMetadata.getExportedDictionaries();

        // the external views are guaranteed not to conflict; checked during construction
        for (String moduleExportedDict : moduleExportedDicts) {
          expDicts.add(moduleExportedDict);
        }
      }
    }

    return expDicts.toArray(new String[0]);
  }

  /**
   * Returns the list of all qualified function names marked as exported via
   * <code>export function</code> statements within the module set.
   * 
   * @return a list of qualified names of all functions marked as exported within the module set
   */
  @Override
  public String[] getExportedFunctions() {
    ArrayList<String> exportedFuncs = new ArrayList<String>();
    if (modules != null) {
      for (ModuleMetadata moduleMetadata : modules) {
        String[] moduleExportedFuncs = moduleMetadata.getExportedFunctions();

        // the external views are guaranteed not to conflict; checked during construction
        for (String moduleExportedFunc : moduleExportedFuncs) {
          exportedFuncs.add(moduleExportedFunc);
        }
      }
    }
    return exportedFuncs.toArray(new String[0]);
  }

  /**
   * Identifies the product version of each module within the module set and returns the most recent
   * product version.
   * 
   * @return the most recent product version used to compile the modules in the module set
   */
  @Override
  public String getProductVersion() {
    String latestVersion = null;

    if (modules != null) {
      for (ModuleMetadata moduleMetadata : modules) {
        String productVersion = moduleMetadata.getProductVersion();

        // first module, save its version as the latest version
        if (latestVersion == null) {
          latestVersion = productVersion;
        }
        // subsequent modules, check to see if it was compiled using a newer version
        // if so, save it as the latest version
        else {
          String v1 = normalize(latestVersion);
          String v2 = normalize(productVersion);
          if (v1.compareTo(v2) < 0) {
            latestVersion = productVersion;
          }
        }
      }
    }
    return latestVersion;
  }

  // pads out version numbers to 4 digits per version level to ensure correct comparison
  private static String normalize(String version) {
    String[] split = Pattern.compile(".", Pattern.LITERAL).split(version);
    StringBuilder sb = new StringBuilder();
    for (String s : split) {
      sb.append(String.format("%4s", s));
    }
    return sb.toString();

  }

  /**
   * Returns the tokenizer type used during compilation of the modules within the module set. This
   * type will be the same for all modules within the set, as it is validated within the
   * constructor.
   * 
   * @return tokenizer type used for compiling this module
   */
  @Override
  public String getTokenizerType() {

    if (modules != null) {
      // all modules within the module set must have the same tokenizer type, so just
      // return the tokenizer type from the first module in the set
      return (modules.get(0)).getTokenizerType();
    } else {
      return null;
    }
  }

  /*
   * INHERITED METHODS NOT APPLICABLE TO MULTIPLE MODULE METADATA
   */

  /*
   * APIs for internal consumer: Runtime and Tooling code
   */

  /**
   * Returns an empty module metadata instance. This method is just for internal use, hence not part
   * of public {@link ModuleMetadata} interface.
   * 
   * @return an empty module metadata instance
   */
  public static MultiModuleMetadataImpl createEmptyMMDInstance() {
    MultiModuleMetadataImpl emptyMD = new MultiModuleMetadataImpl();
    emptyMD.setModuleNames(new TreeSet<String>());
    emptyMD.setModules(new ArrayList<ModuleMetadataImpl>());

    return emptyMD;
  }

  /**
   * Returns list of dictionary names, marked coming from external table.
   * 
   * @return names of dictionaries, whose entries are coming from external table
   */
  public String[] getDictComingFromExtTable() {
    ArrayList<String> dictComingFromExtTable = new ArrayList<String>();
    if (modules != null) {
      for (ModuleMetadata moduleMetadata : modules) {
        String[] moduleDictsFromExtTable =
            ((ModuleMetadataImpl) moduleMetadata).getDictComingFromExtTable();

        // the dicts are guaranteed not to conflict; checked during construction
        for (String moduleDict : moduleDictsFromExtTable) {
          dictComingFromExtTable.add(moduleDict);
        }
      }
    }
    return dictComingFromExtTable.toArray(new String[0]);
  }

  /**
   * Validates that all tokenizer types in modules contained with this metadata object are the same.
   * 
   * @throws IncompatibleTokenizerConfigException
   */
  public void validateTokenizerCompatibility() throws IncompatibleTokenizerConfigException {
    String tokenizerType = null;
    String firstModuleName = null;

    if (modules != null) {
      for (ModuleMetadata moduleMetadata : modules) {
        String newTokenizerType = moduleMetadata.getTokenizerType();

        if (tokenizerType == null) {
          tokenizerType = newTokenizerType;
          firstModuleName = moduleMetadata.getModuleName();
        } else {

          if (false == tokenizerType.equals(newTokenizerType)) {
            throw new IncompatibleTokenizerConfigException(firstModuleName,
                moduleMetadata.getModuleName(), tokenizerType, newTokenizerType);
          }
        }
      }
    }
  }

  /**
   * Verifies if document schema of all modules in the module set are compatible with each other.
   * Two document schemas are compatible if they do not have conflicting field names with
   * conflicting types.
   */
  public void validateDocSchemaCompatibility() throws ModuleLoadException {
    StringBuilder errorString = new StringBuilder();

    if (modules != null) {
      for (int i = 0; i < modules.size(); i++) {
        ModuleMetadata meta1 = modules.get(i);

        for (int j = i + 1; j < modules.size(); j++) {
          ModuleMetadata meta2 = modules.get(j);
          try {
            checkSchemaCompatibility(meta1, meta2);
          } catch (DocSchemaMismatchException e) {
            // capture the error message and continue with next module, so that we can report all
            // errors in one shot
            errorString.append(e.getMessage()).append(Constants.NEW_LINE);
          }
        }
      }
    }

    if (errorString.length() > 0) {
      throw new ModuleLoadException(Arrays.asList(getModuleNames()),
          new DocSchemaMismatchException(errorString.toString()));
    }
  }

  /**
   * Helper method that does schema compatibility check.
   * 
   * @param meta1 metadata of first module to check for compatibility
   * @param meta2 metadata of second module to check for compatibility
   * @throws DocSchemaMismatchException
   */
  private static void checkSchemaCompatibility(ModuleMetadata meta1, ModuleMetadata meta2)
      throws DocSchemaMismatchException {
    TupleSchema schema1 = meta1.getDocSchema();
    TupleSchema schema2 = meta2.getDocSchema();

    for (String fieldName : schema2.getFieldNames()) {
      if (schema1.containsField(fieldName)) {
        // duplicate found, check for clashing type by comparing typenames
        // don't do a fieldtype.equals() check because text types compare the underlying document
        // type as well.
        if (schema1.getFieldTypeByName(fieldName).getTypeName()
            .equals(schema2.getFieldTypeByName(fieldName).getTypeName())) {
          continue;
        } else {
          // types clash, throw exception
          throw new DocSchemaMismatchException(fieldName, meta1.getModuleName(),
              meta2.getModuleName(), schema1.getFieldTypeByName(fieldName).toString(),
              schema2.getFieldTypeByName(fieldName).toString());
        }
      }
    }
  }

  /**
   * This method verifies that the modules in the module set do not have conflicting output names.
   * Output alias names from one module can have conflict with either output alias or qualified view
   * name from another module and vice versa.
   * 
   * @throws ModuleLoadException if there are modules with conflicting output names
   */
  public void validateConflictingOutputNames() throws ModuleLoadException {
    StringBuilder errorString = new StringBuilder();
    Set<String> erroneousModules = new HashSet<String>();

    // String[] moduleNames = nameToTAM.keySet ().toArray (new String[0]);

    if (modules != null) {
      for (int i = 0; i < modules.size(); i++) {
        ModuleMetadata meta1 = modules.get(i);

        // Fetch the list of output names from module meta-data. We would also need a separate list
        // of
        // output aliases from module module1
        List<String> module1OutputNames = Arrays.asList(meta1.getOutputViews());
        List<String> module1OutputAliases = ((ModuleMetadataImpl) meta1).getOutputAliasNames();

        for (int j = i + 1; j < modules.size(); j++) {
          ModuleMetadata meta2 = modules.get(j);

          List<String> module2OutputNames = Arrays.asList(meta2.getOutputViews());
          List<String> module2OutputAliases = ((ModuleMetadataImpl) meta2).getOutputAliasNames();

          // Identify conflicting output names by intersecting the output aliases from ‘module1’
          // with output names from
          // ‘module2’ and vice versa
          module2OutputAliases.retainAll(module1OutputNames);
          module1OutputAliases.retainAll(module2OutputNames);

          if (!module2OutputAliases.isEmpty() || !module1OutputAliases.isEmpty()) {
            // If here, there are conflicting output names between module1 and module2
            erroneousModules.add(meta2.getModuleName());
            erroneousModules.add(meta1.getModuleName());

            // Prepare list of conflicting output names
            List<String> conflictingAliases = new ArrayList<String>();
            if (!module2OutputAliases.isEmpty())
              conflictingAliases.addAll(module2OutputAliases);

            if (!module1OutputAliases.isEmpty())
              conflictingAliases.addAll(module1OutputAliases);

            errorString.append(String.format(
                "Modules '%s' and '%s' are not compatible because they output views under the same name. The conflicting output view names are: %s.\n",
                meta1.getModuleName(), meta2.getModuleName(), conflictingAliases.toString()));
          }
        }
      }
    }
    if (erroneousModules.size() > 0)
      throw new ModuleLoadException(new ArrayList<String>(erroneousModules),
          String.format("%s Provide a list of compatible modules.",
              errorString.substring(0, errorString.length() - 1)));

  }

  /**
   * This method verifies that the modules in the module set do not have conflicting element names.
   * 
   * @throws ModuleLoadException if there are modules with conflicting element names
   */
  public void validateConflictingElementNames() throws ModuleLoadException {
    StringBuilder errorString = new StringBuilder();
    Set<String> erroneousModules = new HashSet<String>();

    if (modules != null) {
      for (int i = 0; i < modules.size(); i++) {
        ModuleMetadata meta1 = modules.get(i);

        // Fetch the lists of exported elements from module1
        List<String> module1ExportedViews = Arrays.asList(meta1.getExportedViews());
        List<String> module1ExportedTables = Arrays.asList(meta1.getExportedTables());
        List<String> module1ExportedDicts = Arrays.asList(meta1.getExportedDictionaries());
        List<String> module1ExportedFunctions = Arrays.asList(meta1.getExportedFunctions());

        for (int j = i + 1; j < modules.size(); j++) {
          ModuleMetadata meta2 = modules.get(j);

          // Arrays.asList creates an immutable list, so create a mutable list from the contents of
          // the immutable list, to take the intersection of this list with the associated list from
          // 'module1'
          List<String> module2ExportedViews =
              new ArrayList<String>(Arrays.asList(meta2.getExportedViews()));
          List<String> module2ExportedTables =
              new ArrayList<String>(Arrays.asList(meta2.getExportedTables()));
          List<String> module2ExportedDicts =
              new ArrayList<String>(Arrays.asList(meta2.getExportedDictionaries()));
          List<String> module2ExportedFunctions =
              new ArrayList<String>(Arrays.asList(meta2.getExportedFunctions()));

          // Identify conflicting output names by intersecting the exported elements from ‘module1’
          // with the exported
          // elements of the same type from 'module2'
          module2ExportedViews.retainAll(module1ExportedViews);
          module2ExportedTables.retainAll(module1ExportedTables);
          module2ExportedDicts.retainAll(module1ExportedDicts);
          module2ExportedFunctions.retainAll(module1ExportedFunctions);

          boolean conflictExists = false;

          if (false == module2ExportedViews.isEmpty()) {
            conflictExists = true;

            errorString.append(String.format(
                "Modules '%s' and '%s' are not compatible because they export views under the same name. The conflicting exported view names are: %s.\n",
                meta1.getModuleName(), meta2.getModuleName(), module2ExportedViews.toString()));
          }

          if (false == module2ExportedTables.isEmpty()) {
            conflictExists = true;

            errorString.append(String.format(
                "Modules '%s' and '%s' are not compatible because they export tables under the same name. The conflicting exported table names are: %s.\n",
                meta1.getModuleName(), meta2.getModuleName(), module2ExportedTables.toString()));
          }

          if (false == module2ExportedDicts.isEmpty()) {
            conflictExists = true;

            errorString.append(String.format(
                "Modules '%s' and '%s' are not compatible because they export dictionaries under the same name. The conflicting exported dictionary names are: %s.\n",
                meta1.getModuleName(), meta2.getModuleName(), module2ExportedDicts.toString()));
          }

          if (false == module2ExportedFunctions.isEmpty()) {
            conflictExists = true;

            errorString.append(String.format(
                "Modules '%s' and '%s' are not compatible because they export functions under the same name. The conflicting exported function names are: %s.\n",
                meta1.getModuleName(), meta2.getModuleName(), module2ExportedFunctions.toString()));
          }

          if (conflictExists) {
            // If here, there are conflicting element names between module1 and module2
            erroneousModules.add(meta2.getModuleName());
            erroneousModules.add(meta1.getModuleName());
          }
        }
      }
    }
    if (erroneousModules.size() > 0)
      throw new ModuleLoadException(new ArrayList<String>(erroneousModules),
          String.format("%s Provide a list of compatible modules.",
              errorString.substring(0, errorString.length() - 1)));

  }

  @Override
  public boolean equals(Object obj) {
    if (false == obj instanceof MultiModuleMetadataImpl)
      return false;

    if (null == obj)
      return false;
    MultiModuleMetadataImpl other = (MultiModuleMetadataImpl) obj;

    // Note: DO NOT compare tokenizer type for now, since there are several .tam files in the
    // 'expected' test directory
    // that contain older tokenizer String, viz., LW_TOKENIZER. Also, as of v2.0, the modulemetadata
    // comparison was
    // skipping the first 2 lines of metadata.xml, so tokenizer was not compared in v2.0 as well.
    // TODO: When time permits, uncomment the following and replace all .tam files in 'expected'
    // directory with modules
    // containing proper metadata.xml

    // tokenizer type
    // if (false == ObjectComparator.equals (this.tokenizerType, other.tokenizerType)) { throw new
    // ModuleMetadataMismatchException (
    // moduleName, "tokenizerType", this.tokenizerType, other.tokenizerType); }

    // module names
    if (false == ObjectComparator.equals(this.getModuleNames(), other.getModuleNames())) {
      throw new ModuleMetadataMismatchException(moduleNames.toString(), "moduleNames",
          String.valueOf(this.getModuleNames()), String.valueOf(other.getModuleNames()));
    }

    // return true, if all checks have passed
    return true;
  }

  @Override
  public int hashCode() {
    throw new FatalInternalError("Hashcode not implemented for class %s.",
        this.getClass().getSimpleName());
  }

  /**
   * Pretty-print the metadata for debugging
   */
  public void dump() {
    String[] mNames = getModuleNames();
    System.out.println("MultiModuleMetadata contents:");
    System.out.println("-----------------------------");
    System.out.println("Modules : " + Arrays.toString(mNames));
    System.out.println("Product version: " + getProductVersion());
    System.out.println("Tokenizer: " + getTokenizerType().toString());

    System.out.println("Doc schema: " + getDocSchema());
    System.out.println();
    System.out.println("Output views: " + Arrays.toString(getOutputViews()));
    System.out.println("Exported views: " + Arrays.toString(getExportedViews()));
    System.out.print("External view pairs: ");
    List<Pair<String, String>> extViews = getExternalViews();
    for (Pair<String, String> extViewPair : extViews) {
      System.out.print(extViewPair.toString());
      System.out.print(", ");
    }
    System.out.println();
    System.out.println();
    System.out.println("External tables: " + Arrays.toString(getExternalTables()));
    System.out.println("Exported tables: " + Arrays.toString(getExportedTables()));
    System.out.println();
    System.out.println("External dicts: " + Arrays.toString(getExternalDictionaries()));
    System.out.println("Exported dicts: " + Arrays.toString(getExportedDictionaries()));
    System.out.println();
    System.out.println("Exported functions: " + Arrays.toString(getExportedFunctions()));

  }
}
